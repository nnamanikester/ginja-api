// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  amenitiesOptions: (where?: AmenitiesOptionsWhereInput) => Promise<boolean>;
  auth: (where?: AuthWhereInput) => Promise<boolean>;
  bank: (where?: BankWhereInput) => Promise<boolean>;
  countries: (where?: CountriesWhereInput) => Promise<boolean>;
  floorsOptions: (where?: FloorsOptionsWhereInput) => Promise<boolean>;
  identificationsOptions: (
    where?: IdentificationsOptionsWhereInput
  ) => Promise<boolean>;
  listing: (where?: ListingWhereInput) => Promise<boolean>;
  listingAvailability: (
    where?: ListingAvailabilityWhereInput
  ) => Promise<boolean>;
  listingDimensions: (where?: ListingDimensionsWhereInput) => Promise<boolean>;
  listingPhotos: (where?: ListingPhotosWhereInput) => Promise<boolean>;
  listingProducts: (where?: ListingProductsWhereInput) => Promise<boolean>;
  listingRating: (where?: ListingRatingWhereInput) => Promise<boolean>;
  listingRequirements: (
    where?: ListingRequirementsWhereInput
  ) => Promise<boolean>;
  listingsFrequencies: (
    where?: ListingsFrequenciesWhereInput
  ) => Promise<boolean>;
  locations: (where?: LocationsWhereInput) => Promise<boolean>;
  organization: (where?: OrganizationWhereInput) => Promise<boolean>;
  organizationType: (where?: OrganizationTypeWhereInput) => Promise<boolean>;
  otp: (where?: OtpWhereInput) => Promise<boolean>;
  propertiesOptions: (where?: PropertiesOptionsWhereInput) => Promise<boolean>;
  rating: (where?: RatingWhereInput) => Promise<boolean>;
  requisition: (where?: RequisitionWhereInput) => Promise<boolean>;
  requisitionCost: (where?: RequisitionCostWhereInput) => Promise<boolean>;
  requisitionDuration: (
    where?: RequisitionDurationWhereInput
  ) => Promise<boolean>;
  role: (where?: RoleWhereInput) => Promise<boolean>;
  roofingMaterialOptions: (
    where?: RoofingMaterialOptionsWhereInput
  ) => Promise<boolean>;
  selectOptions: (where?: SelectOptionsWhereInput) => Promise<boolean>;
  spacesOptions: (where?: SpacesOptionsWhereInput) => Promise<boolean>;
  states: (where?: StatesWhereInput) => Promise<boolean>;
  success: (where?: SuccessWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userOrganizationRole: (
    where?: UserOrganizationRoleWhereInput
  ) => Promise<boolean>;
  valueAddedServices: (
    where?: ValueAddedServicesWhereInput
  ) => Promise<boolean>;
  wallFinishesOptions: (
    where?: WallFinishesOptionsWhereInput
  ) => Promise<boolean>;
  warehouserIdentification: (
    where?: WarehouserIdentificationWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  amenitiesOptions: (
    where: AmenitiesOptionsWhereUniqueInput
  ) => AmenitiesOptionsNullablePromise;
  amenitiesOptionses: (args?: {
    where?: AmenitiesOptionsWhereInput;
    orderBy?: AmenitiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AmenitiesOptions>;
  amenitiesOptionsesConnection: (args?: {
    where?: AmenitiesOptionsWhereInput;
    orderBy?: AmenitiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AmenitiesOptionsConnectionPromise;
  auth: (where: AuthWhereUniqueInput) => AuthNullablePromise;
  auths: (args?: {
    where?: AuthWhereInput;
    orderBy?: AuthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Auth>;
  authsConnection: (args?: {
    where?: AuthWhereInput;
    orderBy?: AuthOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthConnectionPromise;
  bank: (where: BankWhereUniqueInput) => BankNullablePromise;
  banks: (args?: {
    where?: BankWhereInput;
    orderBy?: BankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bank>;
  banksConnection: (args?: {
    where?: BankWhereInput;
    orderBy?: BankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BankConnectionPromise;
  countries: (where: CountriesWhereUniqueInput) => CountriesNullablePromise;
  countrieses: (args?: {
    where?: CountriesWhereInput;
    orderBy?: CountriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Countries>;
  countriesesConnection: (args?: {
    where?: CountriesWhereInput;
    orderBy?: CountriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CountriesConnectionPromise;
  floorsOptions: (
    where: FloorsOptionsWhereUniqueInput
  ) => FloorsOptionsNullablePromise;
  floorsOptionses: (args?: {
    where?: FloorsOptionsWhereInput;
    orderBy?: FloorsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FloorsOptions>;
  floorsOptionsesConnection: (args?: {
    where?: FloorsOptionsWhereInput;
    orderBy?: FloorsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FloorsOptionsConnectionPromise;
  identificationsOptions: (
    where: IdentificationsOptionsWhereUniqueInput
  ) => IdentificationsOptionsNullablePromise;
  identificationsOptionses: (args?: {
    where?: IdentificationsOptionsWhereInput;
    orderBy?: IdentificationsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<IdentificationsOptions>;
  identificationsOptionsesConnection: (args?: {
    where?: IdentificationsOptionsWhereInput;
    orderBy?: IdentificationsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IdentificationsOptionsConnectionPromise;
  listing: (where: ListingWhereUniqueInput) => ListingNullablePromise;
  listings: (args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Listing>;
  listingsConnection: (args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingConnectionPromise;
  listingAvailability: (
    where: ListingAvailabilityWhereUniqueInput
  ) => ListingAvailabilityNullablePromise;
  listingAvailabilities: (args?: {
    where?: ListingAvailabilityWhereInput;
    orderBy?: ListingAvailabilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingAvailability>;
  listingAvailabilitiesConnection: (args?: {
    where?: ListingAvailabilityWhereInput;
    orderBy?: ListingAvailabilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingAvailabilityConnectionPromise;
  listingDimensions: (
    where: ListingDimensionsWhereUniqueInput
  ) => ListingDimensionsNullablePromise;
  listingDimensionses: (args?: {
    where?: ListingDimensionsWhereInput;
    orderBy?: ListingDimensionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingDimensions>;
  listingDimensionsesConnection: (args?: {
    where?: ListingDimensionsWhereInput;
    orderBy?: ListingDimensionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingDimensionsConnectionPromise;
  listingPhotos: (
    where: ListingPhotosWhereUniqueInput
  ) => ListingPhotosNullablePromise;
  listingPhotoses: (args?: {
    where?: ListingPhotosWhereInput;
    orderBy?: ListingPhotosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingPhotos>;
  listingPhotosesConnection: (args?: {
    where?: ListingPhotosWhereInput;
    orderBy?: ListingPhotosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingPhotosConnectionPromise;
  listingProducts: (
    where: ListingProductsWhereUniqueInput
  ) => ListingProductsNullablePromise;
  listingProductses: (args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingProducts>;
  listingProductsesConnection: (args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingProductsConnectionPromise;
  listingRating: (
    where: ListingRatingWhereUniqueInput
  ) => ListingRatingNullablePromise;
  listingRatings: (args?: {
    where?: ListingRatingWhereInput;
    orderBy?: ListingRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingRating>;
  listingRatingsConnection: (args?: {
    where?: ListingRatingWhereInput;
    orderBy?: ListingRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingRatingConnectionPromise;
  listingRequirements: (
    where: ListingRequirementsWhereUniqueInput
  ) => ListingRequirementsNullablePromise;
  listingRequirementses: (args?: {
    where?: ListingRequirementsWhereInput;
    orderBy?: ListingRequirementsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingRequirements>;
  listingRequirementsesConnection: (args?: {
    where?: ListingRequirementsWhereInput;
    orderBy?: ListingRequirementsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingRequirementsConnectionPromise;
  listingsFrequencies: (
    where: ListingsFrequenciesWhereUniqueInput
  ) => ListingsFrequenciesNullablePromise;
  listingsFrequencieses: (args?: {
    where?: ListingsFrequenciesWhereInput;
    orderBy?: ListingsFrequenciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ListingsFrequencies>;
  listingsFrequenciesesConnection: (args?: {
    where?: ListingsFrequenciesWhereInput;
    orderBy?: ListingsFrequenciesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingsFrequenciesConnectionPromise;
  locations: (where: LocationsWhereUniqueInput) => LocationsNullablePromise;
  locationses: (args?: {
    where?: LocationsWhereInput;
    orderBy?: LocationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Locations>;
  locationsesConnection: (args?: {
    where?: LocationsWhereInput;
    orderBy?: LocationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationsConnectionPromise;
  organization: (
    where: OrganizationWhereUniqueInput
  ) => OrganizationNullablePromise;
  organizations: (args?: {
    where?: OrganizationWhereInput;
    orderBy?: OrganizationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Organization>;
  organizationsConnection: (args?: {
    where?: OrganizationWhereInput;
    orderBy?: OrganizationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrganizationConnectionPromise;
  organizationType: (
    where: OrganizationTypeWhereUniqueInput
  ) => OrganizationTypeNullablePromise;
  organizationTypes: (args?: {
    where?: OrganizationTypeWhereInput;
    orderBy?: OrganizationTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrganizationType>;
  organizationTypesConnection: (args?: {
    where?: OrganizationTypeWhereInput;
    orderBy?: OrganizationTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrganizationTypeConnectionPromise;
  otp: (where: OtpWhereUniqueInput) => OtpNullablePromise;
  otps: (args?: {
    where?: OtpWhereInput;
    orderBy?: OtpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Otp>;
  otpsConnection: (args?: {
    where?: OtpWhereInput;
    orderBy?: OtpOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OtpConnectionPromise;
  propertiesOptions: (
    where: PropertiesOptionsWhereUniqueInput
  ) => PropertiesOptionsNullablePromise;
  propertiesOptionses: (args?: {
    where?: PropertiesOptionsWhereInput;
    orderBy?: PropertiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PropertiesOptions>;
  propertiesOptionsesConnection: (args?: {
    where?: PropertiesOptionsWhereInput;
    orderBy?: PropertiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PropertiesOptionsConnectionPromise;
  rating: (where: RatingWhereUniqueInput) => RatingNullablePromise;
  ratings: (args?: {
    where?: RatingWhereInput;
    orderBy?: RatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Rating>;
  ratingsConnection: (args?: {
    where?: RatingWhereInput;
    orderBy?: RatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RatingConnectionPromise;
  requisition: (
    where: RequisitionWhereUniqueInput
  ) => RequisitionNullablePromise;
  requisitions: (args?: {
    where?: RequisitionWhereInput;
    orderBy?: RequisitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Requisition>;
  requisitionsConnection: (args?: {
    where?: RequisitionWhereInput;
    orderBy?: RequisitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequisitionConnectionPromise;
  requisitionCost: (
    where: RequisitionCostWhereUniqueInput
  ) => RequisitionCostNullablePromise;
  requisitionCosts: (args?: {
    where?: RequisitionCostWhereInput;
    orderBy?: RequisitionCostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RequisitionCost>;
  requisitionCostsConnection: (args?: {
    where?: RequisitionCostWhereInput;
    orderBy?: RequisitionCostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequisitionCostConnectionPromise;
  requisitionDuration: (
    where: RequisitionDurationWhereUniqueInput
  ) => RequisitionDurationNullablePromise;
  requisitionDurations: (args?: {
    where?: RequisitionDurationWhereInput;
    orderBy?: RequisitionDurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RequisitionDuration>;
  requisitionDurationsConnection: (args?: {
    where?: RequisitionDurationWhereInput;
    orderBy?: RequisitionDurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequisitionDurationConnectionPromise;
  role: (where: RoleWhereUniqueInput) => RoleNullablePromise;
  roles: (args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Role>;
  rolesConnection: (args?: {
    where?: RoleWhereInput;
    orderBy?: RoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoleConnectionPromise;
  roofingMaterialOptions: (
    where: RoofingMaterialOptionsWhereUniqueInput
  ) => RoofingMaterialOptionsNullablePromise;
  roofingMaterialOptionses: (args?: {
    where?: RoofingMaterialOptionsWhereInput;
    orderBy?: RoofingMaterialOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RoofingMaterialOptions>;
  roofingMaterialOptionsesConnection: (args?: {
    where?: RoofingMaterialOptionsWhereInput;
    orderBy?: RoofingMaterialOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoofingMaterialOptionsConnectionPromise;
  selectOptions: (
    where: SelectOptionsWhereUniqueInput
  ) => SelectOptionsNullablePromise;
  selectOptionses: (args?: {
    where?: SelectOptionsWhereInput;
    orderBy?: SelectOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SelectOptions>;
  selectOptionsesConnection: (args?: {
    where?: SelectOptionsWhereInput;
    orderBy?: SelectOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SelectOptionsConnectionPromise;
  spacesOptions: (
    where: SpacesOptionsWhereUniqueInput
  ) => SpacesOptionsNullablePromise;
  spacesOptionses: (args?: {
    where?: SpacesOptionsWhereInput;
    orderBy?: SpacesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SpacesOptions>;
  spacesOptionsesConnection: (args?: {
    where?: SpacesOptionsWhereInput;
    orderBy?: SpacesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpacesOptionsConnectionPromise;
  states: (where: StatesWhereUniqueInput) => StatesNullablePromise;
  stateses: (args?: {
    where?: StatesWhereInput;
    orderBy?: StatesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<States>;
  statesesConnection: (args?: {
    where?: StatesWhereInput;
    orderBy?: StatesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StatesConnectionPromise;
  success: (where: SuccessWhereUniqueInput) => SuccessNullablePromise;
  successes: (args?: {
    where?: SuccessWhereInput;
    orderBy?: SuccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Success>;
  successesConnection: (args?: {
    where?: SuccessWhereInput;
    orderBy?: SuccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SuccessConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userOrganizationRole: (
    where: UserOrganizationRoleWhereUniqueInput
  ) => UserOrganizationRoleNullablePromise;
  userOrganizationRoles: (args?: {
    where?: UserOrganizationRoleWhereInput;
    orderBy?: UserOrganizationRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserOrganizationRole>;
  userOrganizationRolesConnection: (args?: {
    where?: UserOrganizationRoleWhereInput;
    orderBy?: UserOrganizationRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserOrganizationRoleConnectionPromise;
  valueAddedServices: (
    where: ValueAddedServicesWhereUniqueInput
  ) => ValueAddedServicesNullablePromise;
  valueAddedServiceses: (args?: {
    where?: ValueAddedServicesWhereInput;
    orderBy?: ValueAddedServicesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ValueAddedServices>;
  valueAddedServicesesConnection: (args?: {
    where?: ValueAddedServicesWhereInput;
    orderBy?: ValueAddedServicesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValueAddedServicesConnectionPromise;
  wallFinishesOptions: (
    where: WallFinishesOptionsWhereUniqueInput
  ) => WallFinishesOptionsNullablePromise;
  wallFinishesOptionses: (args?: {
    where?: WallFinishesOptionsWhereInput;
    orderBy?: WallFinishesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WallFinishesOptions>;
  wallFinishesOptionsesConnection: (args?: {
    where?: WallFinishesOptionsWhereInput;
    orderBy?: WallFinishesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WallFinishesOptionsConnectionPromise;
  warehouserIdentification: (
    where: WarehouserIdentificationWhereUniqueInput
  ) => WarehouserIdentificationNullablePromise;
  warehouserIdentifications: (args?: {
    where?: WarehouserIdentificationWhereInput;
    orderBy?: WarehouserIdentificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WarehouserIdentification>;
  warehouserIdentificationsConnection: (args?: {
    where?: WarehouserIdentificationWhereInput;
    orderBy?: WarehouserIdentificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WarehouserIdentificationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAmenitiesOptions: (
    data: AmenitiesOptionsCreateInput
  ) => AmenitiesOptionsPromise;
  updateAmenitiesOptions: (args: {
    data: AmenitiesOptionsUpdateInput;
    where: AmenitiesOptionsWhereUniqueInput;
  }) => AmenitiesOptionsPromise;
  updateManyAmenitiesOptionses: (args: {
    data: AmenitiesOptionsUpdateManyMutationInput;
    where?: AmenitiesOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertAmenitiesOptions: (args: {
    where: AmenitiesOptionsWhereUniqueInput;
    create: AmenitiesOptionsCreateInput;
    update: AmenitiesOptionsUpdateInput;
  }) => AmenitiesOptionsPromise;
  deleteAmenitiesOptions: (
    where: AmenitiesOptionsWhereUniqueInput
  ) => AmenitiesOptionsPromise;
  deleteManyAmenitiesOptionses: (
    where?: AmenitiesOptionsWhereInput
  ) => BatchPayloadPromise;
  createAuth: (data: AuthCreateInput) => AuthPromise;
  updateAuth: (args: {
    data: AuthUpdateInput;
    where: AuthWhereUniqueInput;
  }) => AuthPromise;
  updateManyAuths: (args: {
    data: AuthUpdateManyMutationInput;
    where?: AuthWhereInput;
  }) => BatchPayloadPromise;
  upsertAuth: (args: {
    where: AuthWhereUniqueInput;
    create: AuthCreateInput;
    update: AuthUpdateInput;
  }) => AuthPromise;
  deleteAuth: (where: AuthWhereUniqueInput) => AuthPromise;
  deleteManyAuths: (where?: AuthWhereInput) => BatchPayloadPromise;
  createBank: (data: BankCreateInput) => BankPromise;
  updateBank: (args: {
    data: BankUpdateInput;
    where: BankWhereUniqueInput;
  }) => BankPromise;
  updateManyBanks: (args: {
    data: BankUpdateManyMutationInput;
    where?: BankWhereInput;
  }) => BatchPayloadPromise;
  upsertBank: (args: {
    where: BankWhereUniqueInput;
    create: BankCreateInput;
    update: BankUpdateInput;
  }) => BankPromise;
  deleteBank: (where: BankWhereUniqueInput) => BankPromise;
  deleteManyBanks: (where?: BankWhereInput) => BatchPayloadPromise;
  createCountries: (data: CountriesCreateInput) => CountriesPromise;
  updateCountries: (args: {
    data: CountriesUpdateInput;
    where: CountriesWhereUniqueInput;
  }) => CountriesPromise;
  updateManyCountrieses: (args: {
    data: CountriesUpdateManyMutationInput;
    where?: CountriesWhereInput;
  }) => BatchPayloadPromise;
  upsertCountries: (args: {
    where: CountriesWhereUniqueInput;
    create: CountriesCreateInput;
    update: CountriesUpdateInput;
  }) => CountriesPromise;
  deleteCountries: (where: CountriesWhereUniqueInput) => CountriesPromise;
  deleteManyCountrieses: (where?: CountriesWhereInput) => BatchPayloadPromise;
  createFloorsOptions: (data: FloorsOptionsCreateInput) => FloorsOptionsPromise;
  updateFloorsOptions: (args: {
    data: FloorsOptionsUpdateInput;
    where: FloorsOptionsWhereUniqueInput;
  }) => FloorsOptionsPromise;
  updateManyFloorsOptionses: (args: {
    data: FloorsOptionsUpdateManyMutationInput;
    where?: FloorsOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertFloorsOptions: (args: {
    where: FloorsOptionsWhereUniqueInput;
    create: FloorsOptionsCreateInput;
    update: FloorsOptionsUpdateInput;
  }) => FloorsOptionsPromise;
  deleteFloorsOptions: (
    where: FloorsOptionsWhereUniqueInput
  ) => FloorsOptionsPromise;
  deleteManyFloorsOptionses: (
    where?: FloorsOptionsWhereInput
  ) => BatchPayloadPromise;
  createIdentificationsOptions: (
    data: IdentificationsOptionsCreateInput
  ) => IdentificationsOptionsPromise;
  updateIdentificationsOptions: (args: {
    data: IdentificationsOptionsUpdateInput;
    where: IdentificationsOptionsWhereUniqueInput;
  }) => IdentificationsOptionsPromise;
  updateManyIdentificationsOptionses: (args: {
    data: IdentificationsOptionsUpdateManyMutationInput;
    where?: IdentificationsOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertIdentificationsOptions: (args: {
    where: IdentificationsOptionsWhereUniqueInput;
    create: IdentificationsOptionsCreateInput;
    update: IdentificationsOptionsUpdateInput;
  }) => IdentificationsOptionsPromise;
  deleteIdentificationsOptions: (
    where: IdentificationsOptionsWhereUniqueInput
  ) => IdentificationsOptionsPromise;
  deleteManyIdentificationsOptionses: (
    where?: IdentificationsOptionsWhereInput
  ) => BatchPayloadPromise;
  createListing: (data: ListingCreateInput) => ListingPromise;
  updateListing: (args: {
    data: ListingUpdateInput;
    where: ListingWhereUniqueInput;
  }) => ListingPromise;
  updateManyListings: (args: {
    data: ListingUpdateManyMutationInput;
    where?: ListingWhereInput;
  }) => BatchPayloadPromise;
  upsertListing: (args: {
    where: ListingWhereUniqueInput;
    create: ListingCreateInput;
    update: ListingUpdateInput;
  }) => ListingPromise;
  deleteListing: (where: ListingWhereUniqueInput) => ListingPromise;
  deleteManyListings: (where?: ListingWhereInput) => BatchPayloadPromise;
  createListingAvailability: (
    data: ListingAvailabilityCreateInput
  ) => ListingAvailabilityPromise;
  updateListingAvailability: (args: {
    data: ListingAvailabilityUpdateInput;
    where: ListingAvailabilityWhereUniqueInput;
  }) => ListingAvailabilityPromise;
  updateManyListingAvailabilities: (args: {
    data: ListingAvailabilityUpdateManyMutationInput;
    where?: ListingAvailabilityWhereInput;
  }) => BatchPayloadPromise;
  upsertListingAvailability: (args: {
    where: ListingAvailabilityWhereUniqueInput;
    create: ListingAvailabilityCreateInput;
    update: ListingAvailabilityUpdateInput;
  }) => ListingAvailabilityPromise;
  deleteListingAvailability: (
    where: ListingAvailabilityWhereUniqueInput
  ) => ListingAvailabilityPromise;
  deleteManyListingAvailabilities: (
    where?: ListingAvailabilityWhereInput
  ) => BatchPayloadPromise;
  createListingDimensions: (
    data: ListingDimensionsCreateInput
  ) => ListingDimensionsPromise;
  updateListingDimensions: (args: {
    data: ListingDimensionsUpdateInput;
    where: ListingDimensionsWhereUniqueInput;
  }) => ListingDimensionsPromise;
  updateManyListingDimensionses: (args: {
    data: ListingDimensionsUpdateManyMutationInput;
    where?: ListingDimensionsWhereInput;
  }) => BatchPayloadPromise;
  upsertListingDimensions: (args: {
    where: ListingDimensionsWhereUniqueInput;
    create: ListingDimensionsCreateInput;
    update: ListingDimensionsUpdateInput;
  }) => ListingDimensionsPromise;
  deleteListingDimensions: (
    where: ListingDimensionsWhereUniqueInput
  ) => ListingDimensionsPromise;
  deleteManyListingDimensionses: (
    where?: ListingDimensionsWhereInput
  ) => BatchPayloadPromise;
  createListingPhotos: (data: ListingPhotosCreateInput) => ListingPhotosPromise;
  updateListingPhotos: (args: {
    data: ListingPhotosUpdateInput;
    where: ListingPhotosWhereUniqueInput;
  }) => ListingPhotosPromise;
  updateManyListingPhotoses: (args: {
    data: ListingPhotosUpdateManyMutationInput;
    where?: ListingPhotosWhereInput;
  }) => BatchPayloadPromise;
  upsertListingPhotos: (args: {
    where: ListingPhotosWhereUniqueInput;
    create: ListingPhotosCreateInput;
    update: ListingPhotosUpdateInput;
  }) => ListingPhotosPromise;
  deleteListingPhotos: (
    where: ListingPhotosWhereUniqueInput
  ) => ListingPhotosPromise;
  deleteManyListingPhotoses: (
    where?: ListingPhotosWhereInput
  ) => BatchPayloadPromise;
  createListingProducts: (
    data: ListingProductsCreateInput
  ) => ListingProductsPromise;
  updateListingProducts: (args: {
    data: ListingProductsUpdateInput;
    where: ListingProductsWhereUniqueInput;
  }) => ListingProductsPromise;
  updateManyListingProductses: (args: {
    data: ListingProductsUpdateManyMutationInput;
    where?: ListingProductsWhereInput;
  }) => BatchPayloadPromise;
  upsertListingProducts: (args: {
    where: ListingProductsWhereUniqueInput;
    create: ListingProductsCreateInput;
    update: ListingProductsUpdateInput;
  }) => ListingProductsPromise;
  deleteListingProducts: (
    where: ListingProductsWhereUniqueInput
  ) => ListingProductsPromise;
  deleteManyListingProductses: (
    where?: ListingProductsWhereInput
  ) => BatchPayloadPromise;
  createListingRating: (data: ListingRatingCreateInput) => ListingRatingPromise;
  updateListingRating: (args: {
    data: ListingRatingUpdateInput;
    where: ListingRatingWhereUniqueInput;
  }) => ListingRatingPromise;
  updateManyListingRatings: (args: {
    data: ListingRatingUpdateManyMutationInput;
    where?: ListingRatingWhereInput;
  }) => BatchPayloadPromise;
  upsertListingRating: (args: {
    where: ListingRatingWhereUniqueInput;
    create: ListingRatingCreateInput;
    update: ListingRatingUpdateInput;
  }) => ListingRatingPromise;
  deleteListingRating: (
    where: ListingRatingWhereUniqueInput
  ) => ListingRatingPromise;
  deleteManyListingRatings: (
    where?: ListingRatingWhereInput
  ) => BatchPayloadPromise;
  createListingRequirements: (
    data: ListingRequirementsCreateInput
  ) => ListingRequirementsPromise;
  updateListingRequirements: (args: {
    data: ListingRequirementsUpdateInput;
    where: ListingRequirementsWhereUniqueInput;
  }) => ListingRequirementsPromise;
  updateManyListingRequirementses: (args: {
    data: ListingRequirementsUpdateManyMutationInput;
    where?: ListingRequirementsWhereInput;
  }) => BatchPayloadPromise;
  upsertListingRequirements: (args: {
    where: ListingRequirementsWhereUniqueInput;
    create: ListingRequirementsCreateInput;
    update: ListingRequirementsUpdateInput;
  }) => ListingRequirementsPromise;
  deleteListingRequirements: (
    where: ListingRequirementsWhereUniqueInput
  ) => ListingRequirementsPromise;
  deleteManyListingRequirementses: (
    where?: ListingRequirementsWhereInput
  ) => BatchPayloadPromise;
  createListingsFrequencies: (
    data: ListingsFrequenciesCreateInput
  ) => ListingsFrequenciesPromise;
  updateListingsFrequencies: (args: {
    data: ListingsFrequenciesUpdateInput;
    where: ListingsFrequenciesWhereUniqueInput;
  }) => ListingsFrequenciesPromise;
  updateManyListingsFrequencieses: (args: {
    data: ListingsFrequenciesUpdateManyMutationInput;
    where?: ListingsFrequenciesWhereInput;
  }) => BatchPayloadPromise;
  upsertListingsFrequencies: (args: {
    where: ListingsFrequenciesWhereUniqueInput;
    create: ListingsFrequenciesCreateInput;
    update: ListingsFrequenciesUpdateInput;
  }) => ListingsFrequenciesPromise;
  deleteListingsFrequencies: (
    where: ListingsFrequenciesWhereUniqueInput
  ) => ListingsFrequenciesPromise;
  deleteManyListingsFrequencieses: (
    where?: ListingsFrequenciesWhereInput
  ) => BatchPayloadPromise;
  createLocations: (data: LocationsCreateInput) => LocationsPromise;
  updateLocations: (args: {
    data: LocationsUpdateInput;
    where: LocationsWhereUniqueInput;
  }) => LocationsPromise;
  updateManyLocationses: (args: {
    data: LocationsUpdateManyMutationInput;
    where?: LocationsWhereInput;
  }) => BatchPayloadPromise;
  upsertLocations: (args: {
    where: LocationsWhereUniqueInput;
    create: LocationsCreateInput;
    update: LocationsUpdateInput;
  }) => LocationsPromise;
  deleteLocations: (where: LocationsWhereUniqueInput) => LocationsPromise;
  deleteManyLocationses: (where?: LocationsWhereInput) => BatchPayloadPromise;
  createOrganization: (data: OrganizationCreateInput) => OrganizationPromise;
  updateOrganization: (args: {
    data: OrganizationUpdateInput;
    where: OrganizationWhereUniqueInput;
  }) => OrganizationPromise;
  updateManyOrganizations: (args: {
    data: OrganizationUpdateManyMutationInput;
    where?: OrganizationWhereInput;
  }) => BatchPayloadPromise;
  upsertOrganization: (args: {
    where: OrganizationWhereUniqueInput;
    create: OrganizationCreateInput;
    update: OrganizationUpdateInput;
  }) => OrganizationPromise;
  deleteOrganization: (
    where: OrganizationWhereUniqueInput
  ) => OrganizationPromise;
  deleteManyOrganizations: (
    where?: OrganizationWhereInput
  ) => BatchPayloadPromise;
  createOrganizationType: (
    data: OrganizationTypeCreateInput
  ) => OrganizationTypePromise;
  updateOrganizationType: (args: {
    data: OrganizationTypeUpdateInput;
    where: OrganizationTypeWhereUniqueInput;
  }) => OrganizationTypePromise;
  updateManyOrganizationTypes: (args: {
    data: OrganizationTypeUpdateManyMutationInput;
    where?: OrganizationTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertOrganizationType: (args: {
    where: OrganizationTypeWhereUniqueInput;
    create: OrganizationTypeCreateInput;
    update: OrganizationTypeUpdateInput;
  }) => OrganizationTypePromise;
  deleteOrganizationType: (
    where: OrganizationTypeWhereUniqueInput
  ) => OrganizationTypePromise;
  deleteManyOrganizationTypes: (
    where?: OrganizationTypeWhereInput
  ) => BatchPayloadPromise;
  createOtp: (data: OtpCreateInput) => OtpPromise;
  updateOtp: (args: {
    data: OtpUpdateInput;
    where: OtpWhereUniqueInput;
  }) => OtpPromise;
  updateManyOtps: (args: {
    data: OtpUpdateManyMutationInput;
    where?: OtpWhereInput;
  }) => BatchPayloadPromise;
  upsertOtp: (args: {
    where: OtpWhereUniqueInput;
    create: OtpCreateInput;
    update: OtpUpdateInput;
  }) => OtpPromise;
  deleteOtp: (where: OtpWhereUniqueInput) => OtpPromise;
  deleteManyOtps: (where?: OtpWhereInput) => BatchPayloadPromise;
  createPropertiesOptions: (
    data: PropertiesOptionsCreateInput
  ) => PropertiesOptionsPromise;
  updatePropertiesOptions: (args: {
    data: PropertiesOptionsUpdateInput;
    where: PropertiesOptionsWhereUniqueInput;
  }) => PropertiesOptionsPromise;
  updateManyPropertiesOptionses: (args: {
    data: PropertiesOptionsUpdateManyMutationInput;
    where?: PropertiesOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertPropertiesOptions: (args: {
    where: PropertiesOptionsWhereUniqueInput;
    create: PropertiesOptionsCreateInput;
    update: PropertiesOptionsUpdateInput;
  }) => PropertiesOptionsPromise;
  deletePropertiesOptions: (
    where: PropertiesOptionsWhereUniqueInput
  ) => PropertiesOptionsPromise;
  deleteManyPropertiesOptionses: (
    where?: PropertiesOptionsWhereInput
  ) => BatchPayloadPromise;
  createRating: (data: RatingCreateInput) => RatingPromise;
  updateRating: (args: {
    data: RatingUpdateInput;
    where: RatingWhereUniqueInput;
  }) => RatingPromise;
  updateManyRatings: (args: {
    data: RatingUpdateManyMutationInput;
    where?: RatingWhereInput;
  }) => BatchPayloadPromise;
  upsertRating: (args: {
    where: RatingWhereUniqueInput;
    create: RatingCreateInput;
    update: RatingUpdateInput;
  }) => RatingPromise;
  deleteRating: (where: RatingWhereUniqueInput) => RatingPromise;
  deleteManyRatings: (where?: RatingWhereInput) => BatchPayloadPromise;
  createRequisition: (data: RequisitionCreateInput) => RequisitionPromise;
  updateRequisition: (args: {
    data: RequisitionUpdateInput;
    where: RequisitionWhereUniqueInput;
  }) => RequisitionPromise;
  updateManyRequisitions: (args: {
    data: RequisitionUpdateManyMutationInput;
    where?: RequisitionWhereInput;
  }) => BatchPayloadPromise;
  upsertRequisition: (args: {
    where: RequisitionWhereUniqueInput;
    create: RequisitionCreateInput;
    update: RequisitionUpdateInput;
  }) => RequisitionPromise;
  deleteRequisition: (where: RequisitionWhereUniqueInput) => RequisitionPromise;
  deleteManyRequisitions: (
    where?: RequisitionWhereInput
  ) => BatchPayloadPromise;
  createRequisitionCost: (
    data: RequisitionCostCreateInput
  ) => RequisitionCostPromise;
  updateRequisitionCost: (args: {
    data: RequisitionCostUpdateInput;
    where: RequisitionCostWhereUniqueInput;
  }) => RequisitionCostPromise;
  updateManyRequisitionCosts: (args: {
    data: RequisitionCostUpdateManyMutationInput;
    where?: RequisitionCostWhereInput;
  }) => BatchPayloadPromise;
  upsertRequisitionCost: (args: {
    where: RequisitionCostWhereUniqueInput;
    create: RequisitionCostCreateInput;
    update: RequisitionCostUpdateInput;
  }) => RequisitionCostPromise;
  deleteRequisitionCost: (
    where: RequisitionCostWhereUniqueInput
  ) => RequisitionCostPromise;
  deleteManyRequisitionCosts: (
    where?: RequisitionCostWhereInput
  ) => BatchPayloadPromise;
  createRequisitionDuration: (
    data: RequisitionDurationCreateInput
  ) => RequisitionDurationPromise;
  updateRequisitionDuration: (args: {
    data: RequisitionDurationUpdateInput;
    where: RequisitionDurationWhereUniqueInput;
  }) => RequisitionDurationPromise;
  updateManyRequisitionDurations: (args: {
    data: RequisitionDurationUpdateManyMutationInput;
    where?: RequisitionDurationWhereInput;
  }) => BatchPayloadPromise;
  upsertRequisitionDuration: (args: {
    where: RequisitionDurationWhereUniqueInput;
    create: RequisitionDurationCreateInput;
    update: RequisitionDurationUpdateInput;
  }) => RequisitionDurationPromise;
  deleteRequisitionDuration: (
    where: RequisitionDurationWhereUniqueInput
  ) => RequisitionDurationPromise;
  deleteManyRequisitionDurations: (
    where?: RequisitionDurationWhereInput
  ) => BatchPayloadPromise;
  createRole: (data: RoleCreateInput) => RolePromise;
  updateRole: (args: {
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
  }) => RolePromise;
  updateManyRoles: (args: {
    data: RoleUpdateManyMutationInput;
    where?: RoleWhereInput;
  }) => BatchPayloadPromise;
  upsertRole: (args: {
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
  }) => RolePromise;
  deleteRole: (where: RoleWhereUniqueInput) => RolePromise;
  deleteManyRoles: (where?: RoleWhereInput) => BatchPayloadPromise;
  createRoofingMaterialOptions: (
    data: RoofingMaterialOptionsCreateInput
  ) => RoofingMaterialOptionsPromise;
  updateRoofingMaterialOptions: (args: {
    data: RoofingMaterialOptionsUpdateInput;
    where: RoofingMaterialOptionsWhereUniqueInput;
  }) => RoofingMaterialOptionsPromise;
  updateManyRoofingMaterialOptionses: (args: {
    data: RoofingMaterialOptionsUpdateManyMutationInput;
    where?: RoofingMaterialOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertRoofingMaterialOptions: (args: {
    where: RoofingMaterialOptionsWhereUniqueInput;
    create: RoofingMaterialOptionsCreateInput;
    update: RoofingMaterialOptionsUpdateInput;
  }) => RoofingMaterialOptionsPromise;
  deleteRoofingMaterialOptions: (
    where: RoofingMaterialOptionsWhereUniqueInput
  ) => RoofingMaterialOptionsPromise;
  deleteManyRoofingMaterialOptionses: (
    where?: RoofingMaterialOptionsWhereInput
  ) => BatchPayloadPromise;
  createSelectOptions: (data: SelectOptionsCreateInput) => SelectOptionsPromise;
  updateSelectOptions: (args: {
    data: SelectOptionsUpdateInput;
    where: SelectOptionsWhereUniqueInput;
  }) => SelectOptionsPromise;
  updateManySelectOptionses: (args: {
    data: SelectOptionsUpdateManyMutationInput;
    where?: SelectOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertSelectOptions: (args: {
    where: SelectOptionsWhereUniqueInput;
    create: SelectOptionsCreateInput;
    update: SelectOptionsUpdateInput;
  }) => SelectOptionsPromise;
  deleteSelectOptions: (
    where: SelectOptionsWhereUniqueInput
  ) => SelectOptionsPromise;
  deleteManySelectOptionses: (
    where?: SelectOptionsWhereInput
  ) => BatchPayloadPromise;
  createSpacesOptions: (data: SpacesOptionsCreateInput) => SpacesOptionsPromise;
  updateSpacesOptions: (args: {
    data: SpacesOptionsUpdateInput;
    where: SpacesOptionsWhereUniqueInput;
  }) => SpacesOptionsPromise;
  updateManySpacesOptionses: (args: {
    data: SpacesOptionsUpdateManyMutationInput;
    where?: SpacesOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertSpacesOptions: (args: {
    where: SpacesOptionsWhereUniqueInput;
    create: SpacesOptionsCreateInput;
    update: SpacesOptionsUpdateInput;
  }) => SpacesOptionsPromise;
  deleteSpacesOptions: (
    where: SpacesOptionsWhereUniqueInput
  ) => SpacesOptionsPromise;
  deleteManySpacesOptionses: (
    where?: SpacesOptionsWhereInput
  ) => BatchPayloadPromise;
  createStates: (data: StatesCreateInput) => StatesPromise;
  updateStates: (args: {
    data: StatesUpdateInput;
    where: StatesWhereUniqueInput;
  }) => StatesPromise;
  updateManyStateses: (args: {
    data: StatesUpdateManyMutationInput;
    where?: StatesWhereInput;
  }) => BatchPayloadPromise;
  upsertStates: (args: {
    where: StatesWhereUniqueInput;
    create: StatesCreateInput;
    update: StatesUpdateInput;
  }) => StatesPromise;
  deleteStates: (where: StatesWhereUniqueInput) => StatesPromise;
  deleteManyStateses: (where?: StatesWhereInput) => BatchPayloadPromise;
  createSuccess: (data: SuccessCreateInput) => SuccessPromise;
  updateSuccess: (args: {
    data: SuccessUpdateInput;
    where: SuccessWhereUniqueInput;
  }) => SuccessPromise;
  updateManySuccesses: (args: {
    data: SuccessUpdateManyMutationInput;
    where?: SuccessWhereInput;
  }) => BatchPayloadPromise;
  upsertSuccess: (args: {
    where: SuccessWhereUniqueInput;
    create: SuccessCreateInput;
    update: SuccessUpdateInput;
  }) => SuccessPromise;
  deleteSuccess: (where: SuccessWhereUniqueInput) => SuccessPromise;
  deleteManySuccesses: (where?: SuccessWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserOrganizationRole: (
    data: UserOrganizationRoleCreateInput
  ) => UserOrganizationRolePromise;
  updateUserOrganizationRole: (args: {
    data: UserOrganizationRoleUpdateInput;
    where: UserOrganizationRoleWhereUniqueInput;
  }) => UserOrganizationRolePromise;
  upsertUserOrganizationRole: (args: {
    where: UserOrganizationRoleWhereUniqueInput;
    create: UserOrganizationRoleCreateInput;
    update: UserOrganizationRoleUpdateInput;
  }) => UserOrganizationRolePromise;
  deleteUserOrganizationRole: (
    where: UserOrganizationRoleWhereUniqueInput
  ) => UserOrganizationRolePromise;
  deleteManyUserOrganizationRoles: (
    where?: UserOrganizationRoleWhereInput
  ) => BatchPayloadPromise;
  createValueAddedServices: (
    data: ValueAddedServicesCreateInput
  ) => ValueAddedServicesPromise;
  updateValueAddedServices: (args: {
    data: ValueAddedServicesUpdateInput;
    where: ValueAddedServicesWhereUniqueInput;
  }) => ValueAddedServicesPromise;
  updateManyValueAddedServiceses: (args: {
    data: ValueAddedServicesUpdateManyMutationInput;
    where?: ValueAddedServicesWhereInput;
  }) => BatchPayloadPromise;
  upsertValueAddedServices: (args: {
    where: ValueAddedServicesWhereUniqueInput;
    create: ValueAddedServicesCreateInput;
    update: ValueAddedServicesUpdateInput;
  }) => ValueAddedServicesPromise;
  deleteValueAddedServices: (
    where: ValueAddedServicesWhereUniqueInput
  ) => ValueAddedServicesPromise;
  deleteManyValueAddedServiceses: (
    where?: ValueAddedServicesWhereInput
  ) => BatchPayloadPromise;
  createWallFinishesOptions: (
    data: WallFinishesOptionsCreateInput
  ) => WallFinishesOptionsPromise;
  updateWallFinishesOptions: (args: {
    data: WallFinishesOptionsUpdateInput;
    where: WallFinishesOptionsWhereUniqueInput;
  }) => WallFinishesOptionsPromise;
  updateManyWallFinishesOptionses: (args: {
    data: WallFinishesOptionsUpdateManyMutationInput;
    where?: WallFinishesOptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertWallFinishesOptions: (args: {
    where: WallFinishesOptionsWhereUniqueInput;
    create: WallFinishesOptionsCreateInput;
    update: WallFinishesOptionsUpdateInput;
  }) => WallFinishesOptionsPromise;
  deleteWallFinishesOptions: (
    where: WallFinishesOptionsWhereUniqueInput
  ) => WallFinishesOptionsPromise;
  deleteManyWallFinishesOptionses: (
    where?: WallFinishesOptionsWhereInput
  ) => BatchPayloadPromise;
  createWarehouserIdentification: (
    data: WarehouserIdentificationCreateInput
  ) => WarehouserIdentificationPromise;
  updateWarehouserIdentification: (args: {
    data: WarehouserIdentificationUpdateInput;
    where: WarehouserIdentificationWhereUniqueInput;
  }) => WarehouserIdentificationPromise;
  updateManyWarehouserIdentifications: (args: {
    data: WarehouserIdentificationUpdateManyMutationInput;
    where?: WarehouserIdentificationWhereInput;
  }) => BatchPayloadPromise;
  upsertWarehouserIdentification: (args: {
    where: WarehouserIdentificationWhereUniqueInput;
    create: WarehouserIdentificationCreateInput;
    update: WarehouserIdentificationUpdateInput;
  }) => WarehouserIdentificationPromise;
  deleteWarehouserIdentification: (
    where: WarehouserIdentificationWhereUniqueInput
  ) => WarehouserIdentificationPromise;
  deleteManyWarehouserIdentifications: (
    where?: WarehouserIdentificationWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  amenitiesOptions: (
    where?: AmenitiesOptionsSubscriptionWhereInput
  ) => AmenitiesOptionsSubscriptionPayloadSubscription;
  auth: (
    where?: AuthSubscriptionWhereInput
  ) => AuthSubscriptionPayloadSubscription;
  bank: (
    where?: BankSubscriptionWhereInput
  ) => BankSubscriptionPayloadSubscription;
  countries: (
    where?: CountriesSubscriptionWhereInput
  ) => CountriesSubscriptionPayloadSubscription;
  floorsOptions: (
    where?: FloorsOptionsSubscriptionWhereInput
  ) => FloorsOptionsSubscriptionPayloadSubscription;
  identificationsOptions: (
    where?: IdentificationsOptionsSubscriptionWhereInput
  ) => IdentificationsOptionsSubscriptionPayloadSubscription;
  listing: (
    where?: ListingSubscriptionWhereInput
  ) => ListingSubscriptionPayloadSubscription;
  listingAvailability: (
    where?: ListingAvailabilitySubscriptionWhereInput
  ) => ListingAvailabilitySubscriptionPayloadSubscription;
  listingDimensions: (
    where?: ListingDimensionsSubscriptionWhereInput
  ) => ListingDimensionsSubscriptionPayloadSubscription;
  listingPhotos: (
    where?: ListingPhotosSubscriptionWhereInput
  ) => ListingPhotosSubscriptionPayloadSubscription;
  listingProducts: (
    where?: ListingProductsSubscriptionWhereInput
  ) => ListingProductsSubscriptionPayloadSubscription;
  listingRating: (
    where?: ListingRatingSubscriptionWhereInput
  ) => ListingRatingSubscriptionPayloadSubscription;
  listingRequirements: (
    where?: ListingRequirementsSubscriptionWhereInput
  ) => ListingRequirementsSubscriptionPayloadSubscription;
  listingsFrequencies: (
    where?: ListingsFrequenciesSubscriptionWhereInput
  ) => ListingsFrequenciesSubscriptionPayloadSubscription;
  locations: (
    where?: LocationsSubscriptionWhereInput
  ) => LocationsSubscriptionPayloadSubscription;
  organization: (
    where?: OrganizationSubscriptionWhereInput
  ) => OrganizationSubscriptionPayloadSubscription;
  organizationType: (
    where?: OrganizationTypeSubscriptionWhereInput
  ) => OrganizationTypeSubscriptionPayloadSubscription;
  otp: (
    where?: OtpSubscriptionWhereInput
  ) => OtpSubscriptionPayloadSubscription;
  propertiesOptions: (
    where?: PropertiesOptionsSubscriptionWhereInput
  ) => PropertiesOptionsSubscriptionPayloadSubscription;
  rating: (
    where?: RatingSubscriptionWhereInput
  ) => RatingSubscriptionPayloadSubscription;
  requisition: (
    where?: RequisitionSubscriptionWhereInput
  ) => RequisitionSubscriptionPayloadSubscription;
  requisitionCost: (
    where?: RequisitionCostSubscriptionWhereInput
  ) => RequisitionCostSubscriptionPayloadSubscription;
  requisitionDuration: (
    where?: RequisitionDurationSubscriptionWhereInput
  ) => RequisitionDurationSubscriptionPayloadSubscription;
  role: (
    where?: RoleSubscriptionWhereInput
  ) => RoleSubscriptionPayloadSubscription;
  roofingMaterialOptions: (
    where?: RoofingMaterialOptionsSubscriptionWhereInput
  ) => RoofingMaterialOptionsSubscriptionPayloadSubscription;
  selectOptions: (
    where?: SelectOptionsSubscriptionWhereInput
  ) => SelectOptionsSubscriptionPayloadSubscription;
  spacesOptions: (
    where?: SpacesOptionsSubscriptionWhereInput
  ) => SpacesOptionsSubscriptionPayloadSubscription;
  states: (
    where?: StatesSubscriptionWhereInput
  ) => StatesSubscriptionPayloadSubscription;
  success: (
    where?: SuccessSubscriptionWhereInput
  ) => SuccessSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userOrganizationRole: (
    where?: UserOrganizationRoleSubscriptionWhereInput
  ) => UserOrganizationRoleSubscriptionPayloadSubscription;
  valueAddedServices: (
    where?: ValueAddedServicesSubscriptionWhereInput
  ) => ValueAddedServicesSubscriptionPayloadSubscription;
  wallFinishesOptions: (
    where?: WallFinishesOptionsSubscriptionWhereInput
  ) => WallFinishesOptionsSubscriptionPayloadSubscription;
  warehouserIdentification: (
    where?: WarehouserIdentificationSubscriptionWhereInput
  ) => WarehouserIdentificationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LocationsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "state_ASC"
  | "state_DESC"
  | "geo_ASC"
  | "geo_DESC"
  | "lga_ASC"
  | "lga_DESC"
  | "street_ASC"
  | "street_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type FloorsOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type ListingsFrequenciesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type WarehouserIdentificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "idNumber_ASC"
  | "idNumber_DESC"
  | "expiryDate_ASC"
  | "expiryDate_DESC"
  | "idType_ASC"
  | "idType_DESC";

export type ListingRatingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "count_ASC"
  | "count_DESC"
  | "rates_ASC"
  | "rates_DESC"
  | "average_ASC"
  | "average_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "terms_ASC"
  | "terms_DESC"
  | "type_ASC"
  | "type_DESC";

export type ListingDimensionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "height_ASC"
  | "height_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "length_ASC"
  | "length_DESC"
  | "unitOfDimensions_ASC"
  | "unitOfDimensions_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "area_ASC"
  | "area_DESC";

export type SuccessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "success_ASC"
  | "success_DESC";

export type ListingAvailabilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "from_ASC"
  | "from_DESC"
  | "to_ASC"
  | "to_DESC";

export type SelectOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC";

export type ListingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "description_ASC"
  | "description_DESC"
  | "price_ASC"
  | "price_DESC"
  | "discount_ASC"
  | "discount_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "proofOfOwnership_ASC"
  | "proofOfOwnership_DESC"
  | "windows_ASC"
  | "windows_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "status_ASC"
  | "status_DESC";

export type RequisitionDurationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC";

export type BankOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "accountNumber_ASC"
  | "accountNumber_DESC"
  | "accountName_ASC"
  | "accountName_DESC"
  | "bankName_ASC"
  | "bankName_DESC"
  | "bankCode_ASC"
  | "bankCode_DESC";

export type RequisitionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "expires_ASC"
  | "expires_DESC"
  | "space_ASC"
  | "space_DESC"
  | "status_ASC"
  | "status_DESC";

export type ListingProductsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type OtpOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "code_ASC"
  | "code_DESC"
  | "validated_ASC"
  | "validated_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ListingRequirementsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC";

export type OrganizationOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC";

export type ListingPhotosOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "default_ASC"
  | "default_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ValueAddedServicesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "default_ASC"
  | "default_DESC"
  | "name_ASC"
  | "name_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type AmenitiesOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type RoofingMaterialOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type RoleOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type WallFinishesOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type RatingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "listingId_ASC"
  | "listingId_DESC"
  | "ratingId_ASC"
  | "ratingId_DESC"
  | "rate_ASC"
  | "rate_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type IdentificationsOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type SpacesOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type PropertiesOptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type CountriesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC";

export type OrganizationTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type RequisitionCostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "baseCost_ASC"
  | "baseCost_DESC"
  | "vat_ASC"
  | "vat_DESC"
  | "discount_ASC"
  | "discount_DESC";

export type StatesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "countryId_ASC"
  | "countryId_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "default_ASC"
  | "default_DESC";

export type UserOrganizationRoleOrderByInput = "id_ASC" | "id_DESC";

export type AuthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "pin_ASC"
  | "pin_DESC"
  | "userId_ASC"
  | "userId_DESC";

export interface ListingProductsCreateManyInput {
  create?: Maybe<ListingProductsCreateInput[] | ListingProductsCreateInput>;
  connect?: Maybe<
    ListingProductsWhereUniqueInput[] | ListingProductsWhereUniqueInput
  >;
}

export type AmenitiesOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingsFrequenciesUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingRequirementsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface ListingRequirementsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface SpacesOptionsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingRequirementsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface WarehouserIdentificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WarehouserIdentificationWhereInput>;
  AND?: Maybe<
    | WarehouserIdentificationSubscriptionWhereInput[]
    | WarehouserIdentificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WarehouserIdentificationSubscriptionWhereInput[]
    | WarehouserIdentificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WarehouserIdentificationSubscriptionWhereInput[]
    | WarehouserIdentificationSubscriptionWhereInput
  >;
}

export interface ListingRatingUpdateManyMutationInput {
  count?: Maybe<Int>;
  rates?: Maybe<Int>;
  average?: Maybe<Float>;
}

export interface ValueAddedServicesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValueAddedServicesWhereInput>;
  AND?: Maybe<
    | ValueAddedServicesSubscriptionWhereInput[]
    | ValueAddedServicesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ValueAddedServicesSubscriptionWhereInput[]
    | ValueAddedServicesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ValueAddedServicesSubscriptionWhereInput[]
    | ValueAddedServicesSubscriptionWhereInput
  >;
}

export type SuccessWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserOrganizationRoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserOrganizationRoleWhereInput>;
  AND?: Maybe<
    | UserOrganizationRoleSubscriptionWhereInput[]
    | UserOrganizationRoleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserOrganizationRoleSubscriptionWhereInput[]
    | UserOrganizationRoleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserOrganizationRoleSubscriptionWhereInput[]
    | UserOrganizationRoleSubscriptionWhereInput
  >;
}

export interface ListingRatingUpdateInput {
  count?: Maybe<Int>;
  rates?: Maybe<Int>;
  average?: Maybe<Float>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface SuccessWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  success?: Maybe<Boolean>;
  success_not?: Maybe<Boolean>;
  AND?: Maybe<SuccessWhereInput[] | SuccessWhereInput>;
  OR?: Maybe<SuccessWhereInput[] | SuccessWhereInput>;
  NOT?: Maybe<SuccessWhereInput[] | SuccessWhereInput>;
}

export interface StatesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StatesWhereInput>;
  AND?: Maybe<StatesSubscriptionWhereInput[] | StatesSubscriptionWhereInput>;
  OR?: Maybe<StatesSubscriptionWhereInput[] | StatesSubscriptionWhereInput>;
  NOT?: Maybe<StatesSubscriptionWhereInput[] | StatesSubscriptionWhereInput>;
}

export interface ListingProductsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export type ListingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingProductsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RoofingMaterialOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoofingMaterialOptionsWhereInput>;
  AND?: Maybe<
    | RoofingMaterialOptionsSubscriptionWhereInput[]
    | RoofingMaterialOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RoofingMaterialOptionsSubscriptionWhereInput[]
    | RoofingMaterialOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RoofingMaterialOptionsSubscriptionWhereInput[]
    | RoofingMaterialOptionsSubscriptionWhereInput
  >;
}

export interface ListingPhotosUpdateManyMutationInput {
  url?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface SpacesOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<SpacesOptionsWhereInput[] | SpacesOptionsWhereInput>;
  OR?: Maybe<SpacesOptionsWhereInput[] | SpacesOptionsWhereInput>;
  NOT?: Maybe<SpacesOptionsWhereInput[] | SpacesOptionsWhereInput>;
}

export interface ListingPhotosUpdateInput {
  url?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface RequisitionCostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequisitionCostWhereInput>;
  AND?: Maybe<
    | RequisitionCostSubscriptionWhereInput[]
    | RequisitionCostSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RequisitionCostSubscriptionWhereInput[]
    | RequisitionCostSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RequisitionCostSubscriptionWhereInput[]
    | RequisitionCostSubscriptionWhereInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RequisitionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequisitionWhereInput>;
  AND?: Maybe<
    RequisitionSubscriptionWhereInput[] | RequisitionSubscriptionWhereInput
  >;
  OR?: Maybe<
    RequisitionSubscriptionWhereInput[] | RequisitionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RequisitionSubscriptionWhereInput[] | RequisitionSubscriptionWhereInput
  >;
}

export interface AmenitiesOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<AmenitiesOptionsWhereInput[] | AmenitiesOptionsWhereInput>;
  OR?: Maybe<AmenitiesOptionsWhereInput[] | AmenitiesOptionsWhereInput>;
  NOT?: Maybe<AmenitiesOptionsWhereInput[] | AmenitiesOptionsWhereInput>;
}

export interface WallFinishesOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<WallFinishesOptionsWhereInput[] | WallFinishesOptionsWhereInput>;
  OR?: Maybe<WallFinishesOptionsWhereInput[] | WallFinishesOptionsWhereInput>;
  NOT?: Maybe<WallFinishesOptionsWhereInput[] | WallFinishesOptionsWhereInput>;
}

export interface ListingDimensionsUpdateManyMutationInput {
  height?: Maybe<Float>;
  weight?: Maybe<Float>;
  length?: Maybe<Float>;
  unitOfDimensions?: Maybe<Int>;
  volume?: Maybe<Float>;
  area?: Maybe<Float>;
}

export interface PropertiesOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PropertiesOptionsWhereInput>;
  AND?: Maybe<
    | PropertiesOptionsSubscriptionWhereInput[]
    | PropertiesOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PropertiesOptionsSubscriptionWhereInput[]
    | PropertiesOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PropertiesOptionsSubscriptionWhereInput[]
    | PropertiesOptionsSubscriptionWhereInput
  >;
}

export interface ListingDimensionsUpdateInput {
  height?: Maybe<Float>;
  weight?: Maybe<Float>;
  length?: Maybe<Float>;
  unitOfDimensions?: Maybe<Int>;
  volume?: Maybe<Float>;
  area?: Maybe<Float>;
}

export interface OtpSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OtpWhereInput>;
  AND?: Maybe<OtpSubscriptionWhereInput[] | OtpSubscriptionWhereInput>;
  OR?: Maybe<OtpSubscriptionWhereInput[] | OtpSubscriptionWhereInput>;
  NOT?: Maybe<OtpSubscriptionWhereInput[] | OtpSubscriptionWhereInput>;
}

export interface ListingAvailabilityUpdateManyMutationInput {
  from?: Maybe<String>;
  to?: Maybe<String>;
}

export interface OrganizationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrganizationWhereInput>;
  AND?: Maybe<
    OrganizationSubscriptionWhereInput[] | OrganizationSubscriptionWhereInput
  >;
  OR?: Maybe<
    OrganizationSubscriptionWhereInput[] | OrganizationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OrganizationSubscriptionWhereInput[] | OrganizationSubscriptionWhereInput
  >;
}

export type UserOrganizationRoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ValueAddedServicesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<ValueAddedServicesWhereInput[] | ValueAddedServicesWhereInput>;
  OR?: Maybe<ValueAddedServicesWhereInput[] | ValueAddedServicesWhereInput>;
  NOT?: Maybe<ValueAddedServicesWhereInput[] | ValueAddedServicesWhereInput>;
}

export interface ListingAvailabilityUpdateInput {
  from?: Maybe<String>;
  to?: Maybe<String>;
}

export interface ListingsFrequenciesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingsFrequenciesWhereInput>;
  AND?: Maybe<
    | ListingsFrequenciesSubscriptionWhereInput[]
    | ListingsFrequenciesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ListingsFrequenciesSubscriptionWhereInput[]
    | ListingsFrequenciesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ListingsFrequenciesSubscriptionWhereInput[]
    | ListingsFrequenciesSubscriptionWhereInput
  >;
}

export interface UserOrganizationRoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  role?: Maybe<RoleWhereInput>;
  organization?: Maybe<OrganizationWhereInput>;
  AND?: Maybe<
    UserOrganizationRoleWhereInput[] | UserOrganizationRoleWhereInput
  >;
  OR?: Maybe<UserOrganizationRoleWhereInput[] | UserOrganizationRoleWhereInput>;
  NOT?: Maybe<
    UserOrganizationRoleWhereInput[] | UserOrganizationRoleWhereInput
  >;
}

export interface ListingRequirementsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingRequirementsWhereInput>;
  AND?: Maybe<
    | ListingRequirementsSubscriptionWhereInput[]
    | ListingRequirementsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ListingRequirementsSubscriptionWhereInput[]
    | ListingRequirementsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ListingRequirementsSubscriptionWhereInput[]
    | ListingRequirementsSubscriptionWhereInput
  >;
}

export interface ListingUpdateManyMutationInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  description?: Maybe<String>;
  price?: Maybe<Float>;
  discount?: Maybe<Int>;
  currency?: Maybe<String>;
  proofOfOwnership?: Maybe<String>;
  windows?: Maybe<Int>;
  avatar?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface ListingProductsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingProductsWhereInput>;
  AND?: Maybe<
    | ListingProductsSubscriptionWhereInput[]
    | ListingProductsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ListingProductsSubscriptionWhereInput[]
    | ListingProductsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ListingProductsSubscriptionWhereInput[]
    | ListingProductsSubscriptionWhereInput
  >;
}

export interface ListingRatingUpsertNestedInput {
  update: ListingRatingUpdateDataInput;
  create: ListingRatingCreateInput;
}

export interface ListingPhotosSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingPhotosWhereInput>;
  AND?: Maybe<
    ListingPhotosSubscriptionWhereInput[] | ListingPhotosSubscriptionWhereInput
  >;
  OR?: Maybe<
    ListingPhotosSubscriptionWhereInput[] | ListingPhotosSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ListingPhotosSubscriptionWhereInput[] | ListingPhotosSubscriptionWhereInput
  >;
}

export interface ListingRatingUpdateDataInput {
  count?: Maybe<Int>;
  rates?: Maybe<Int>;
  average?: Maybe<Float>;
}

export interface ListingProductsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<ListingProductsWhereInput[] | ListingProductsWhereInput>;
  OR?: Maybe<ListingProductsWhereInput[] | ListingProductsWhereInput>;
  NOT?: Maybe<ListingProductsWhereInput[] | ListingProductsWhereInput>;
}

export interface ListingRatingUpdateOneRequiredInput {
  create?: Maybe<ListingRatingCreateInput>;
  update?: Maybe<ListingRatingUpdateDataInput>;
  upsert?: Maybe<ListingRatingUpsertNestedInput>;
  connect?: Maybe<ListingRatingWhereUniqueInput>;
}

export interface ListingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingWhereInput>;
  AND?: Maybe<ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput>;
  OR?: Maybe<ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput>;
  NOT?: Maybe<ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput>;
}

export type ValueAddedServicesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FloorsOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FloorsOptionsWhereInput>;
  AND?: Maybe<
    FloorsOptionsSubscriptionWhereInput[] | FloorsOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    FloorsOptionsSubscriptionWhereInput[] | FloorsOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FloorsOptionsSubscriptionWhereInput[] | FloorsOptionsSubscriptionWhereInput
  >;
}

export interface ListingDimensionsUpsertNestedInput {
  update: ListingDimensionsUpdateDataInput;
  create: ListingDimensionsCreateInput;
}

export interface ListingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  discount?: Maybe<Int>;
  discount_not?: Maybe<Int>;
  discount_in?: Maybe<Int[] | Int>;
  discount_not_in?: Maybe<Int[] | Int>;
  discount_lt?: Maybe<Int>;
  discount_lte?: Maybe<Int>;
  discount_gt?: Maybe<Int>;
  discount_gte?: Maybe<Int>;
  currency?: Maybe<String>;
  currency_not?: Maybe<String>;
  currency_in?: Maybe<String[] | String>;
  currency_not_in?: Maybe<String[] | String>;
  currency_lt?: Maybe<String>;
  currency_lte?: Maybe<String>;
  currency_gt?: Maybe<String>;
  currency_gte?: Maybe<String>;
  currency_contains?: Maybe<String>;
  currency_not_contains?: Maybe<String>;
  currency_starts_with?: Maybe<String>;
  currency_not_starts_with?: Maybe<String>;
  currency_ends_with?: Maybe<String>;
  currency_not_ends_with?: Maybe<String>;
  proofOfOwnership?: Maybe<String>;
  proofOfOwnership_not?: Maybe<String>;
  proofOfOwnership_in?: Maybe<String[] | String>;
  proofOfOwnership_not_in?: Maybe<String[] | String>;
  proofOfOwnership_lt?: Maybe<String>;
  proofOfOwnership_lte?: Maybe<String>;
  proofOfOwnership_gt?: Maybe<String>;
  proofOfOwnership_gte?: Maybe<String>;
  proofOfOwnership_contains?: Maybe<String>;
  proofOfOwnership_not_contains?: Maybe<String>;
  proofOfOwnership_starts_with?: Maybe<String>;
  proofOfOwnership_not_starts_with?: Maybe<String>;
  proofOfOwnership_ends_with?: Maybe<String>;
  proofOfOwnership_not_ends_with?: Maybe<String>;
  identification?: Maybe<WarehouserIdentificationWhereInput>;
  spacing_every?: Maybe<SpacesOptionsWhereInput>;
  spacing_some?: Maybe<SpacesOptionsWhereInput>;
  spacing_none?: Maybe<SpacesOptionsWhereInput>;
  property_every?: Maybe<PropertiesOptionsWhereInput>;
  property_some?: Maybe<PropertiesOptionsWhereInput>;
  property_none?: Maybe<PropertiesOptionsWhereInput>;
  floor_every?: Maybe<FloorsOptionsWhereInput>;
  floor_some?: Maybe<FloorsOptionsWhereInput>;
  floor_none?: Maybe<FloorsOptionsWhereInput>;
  wallFinish_every?: Maybe<WallFinishesOptionsWhereInput>;
  wallFinish_some?: Maybe<WallFinishesOptionsWhereInput>;
  wallFinish_none?: Maybe<WallFinishesOptionsWhereInput>;
  roofing_every?: Maybe<RoofingMaterialOptionsWhereInput>;
  roofing_some?: Maybe<RoofingMaterialOptionsWhereInput>;
  roofing_none?: Maybe<RoofingMaterialOptionsWhereInput>;
  isSecure?: Maybe<SelectOptionsWhereInput>;
  pest?: Maybe<SelectOptionsWhereInput>;
  windows?: Maybe<Int>;
  windows_not?: Maybe<Int>;
  windows_in?: Maybe<Int[] | Int>;
  windows_not_in?: Maybe<Int[] | Int>;
  windows_lt?: Maybe<Int>;
  windows_lte?: Maybe<Int>;
  windows_gt?: Maybe<Int>;
  windows_gte?: Maybe<Int>;
  location?: Maybe<LocationsWhereInput>;
  amenities_every?: Maybe<AmenitiesOptionsWhereInput>;
  amenities_some?: Maybe<AmenitiesOptionsWhereInput>;
  amenities_none?: Maybe<AmenitiesOptionsWhereInput>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  vas_every?: Maybe<ValueAddedServicesWhereInput>;
  vas_some?: Maybe<ValueAddedServicesWhereInput>;
  vas_none?: Maybe<ValueAddedServicesWhereInput>;
  listingPhotos_every?: Maybe<ListingPhotosWhereInput>;
  listingPhotos_some?: Maybe<ListingPhotosWhereInput>;
  listingPhotos_none?: Maybe<ListingPhotosWhereInput>;
  frequency?: Maybe<ListingsFrequenciesWhereInput>;
  requirements_every?: Maybe<ListingRequirementsWhereInput>;
  requirements_some?: Maybe<ListingRequirementsWhereInput>;
  requirements_none?: Maybe<ListingRequirementsWhereInput>;
  products_every?: Maybe<ListingProductsWhereInput>;
  products_some?: Maybe<ListingProductsWhereInput>;
  products_none?: Maybe<ListingProductsWhereInput>;
  availability?: Maybe<ListingAvailabilityWhereInput>;
  dimensions?: Maybe<ListingDimensionsWhereInput>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  rating?: Maybe<ListingRatingWhereInput>;
  AND?: Maybe<ListingWhereInput[] | ListingWhereInput>;
  OR?: Maybe<ListingWhereInput[] | ListingWhereInput>;
  NOT?: Maybe<ListingWhereInput[] | ListingWhereInput>;
}

export interface ListingDimensionsUpdateDataInput {
  height?: Maybe<Float>;
  weight?: Maybe<Float>;
  length?: Maybe<Float>;
  unitOfDimensions?: Maybe<Int>;
  volume?: Maybe<Float>;
  area?: Maybe<Float>;
}

export interface SelectOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SelectOptionsWhereInput[] | SelectOptionsWhereInput>;
  OR?: Maybe<SelectOptionsWhereInput[] | SelectOptionsWhereInput>;
  NOT?: Maybe<SelectOptionsWhereInput[] | SelectOptionsWhereInput>;
}

export interface ListingDimensionsUpdateOneRequiredInput {
  create?: Maybe<ListingDimensionsCreateInput>;
  update?: Maybe<ListingDimensionsUpdateDataInput>;
  upsert?: Maybe<ListingDimensionsUpsertNestedInput>;
  connect?: Maybe<ListingDimensionsWhereUniqueInput>;
}

export interface ListingsFrequenciesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<ListingsFrequenciesWhereInput[] | ListingsFrequenciesWhereInput>;
  OR?: Maybe<ListingsFrequenciesWhereInput[] | ListingsFrequenciesWhereInput>;
  NOT?: Maybe<ListingsFrequenciesWhereInput[] | ListingsFrequenciesWhereInput>;
}

export type WallFinishesOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingDimensionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  length?: Maybe<Float>;
  length_not?: Maybe<Float>;
  length_in?: Maybe<Float[] | Float>;
  length_not_in?: Maybe<Float[] | Float>;
  length_lt?: Maybe<Float>;
  length_lte?: Maybe<Float>;
  length_gt?: Maybe<Float>;
  length_gte?: Maybe<Float>;
  unitOfDimensions?: Maybe<Int>;
  unitOfDimensions_not?: Maybe<Int>;
  unitOfDimensions_in?: Maybe<Int[] | Int>;
  unitOfDimensions_not_in?: Maybe<Int[] | Int>;
  unitOfDimensions_lt?: Maybe<Int>;
  unitOfDimensions_lte?: Maybe<Int>;
  unitOfDimensions_gt?: Maybe<Int>;
  unitOfDimensions_gte?: Maybe<Int>;
  volume?: Maybe<Float>;
  volume_not?: Maybe<Float>;
  volume_in?: Maybe<Float[] | Float>;
  volume_not_in?: Maybe<Float[] | Float>;
  volume_lt?: Maybe<Float>;
  volume_lte?: Maybe<Float>;
  volume_gt?: Maybe<Float>;
  volume_gte?: Maybe<Float>;
  area?: Maybe<Float>;
  area_not?: Maybe<Float>;
  area_in?: Maybe<Float[] | Float>;
  area_not_in?: Maybe<Float[] | Float>;
  area_lt?: Maybe<Float>;
  area_lte?: Maybe<Float>;
  area_gt?: Maybe<Float>;
  area_gte?: Maybe<Float>;
  AND?: Maybe<ListingDimensionsWhereInput[] | ListingDimensionsWhereInput>;
  OR?: Maybe<ListingDimensionsWhereInput[] | ListingDimensionsWhereInput>;
  NOT?: Maybe<ListingDimensionsWhereInput[] | ListingDimensionsWhereInput>;
}

export interface ListingAvailabilityUpsertNestedInput {
  update: ListingAvailabilityUpdateDataInput;
  create: ListingAvailabilityCreateInput;
}

export interface BankWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  accountNumber?: Maybe<String>;
  accountNumber_not?: Maybe<String>;
  accountNumber_in?: Maybe<String[] | String>;
  accountNumber_not_in?: Maybe<String[] | String>;
  accountNumber_lt?: Maybe<String>;
  accountNumber_lte?: Maybe<String>;
  accountNumber_gt?: Maybe<String>;
  accountNumber_gte?: Maybe<String>;
  accountNumber_contains?: Maybe<String>;
  accountNumber_not_contains?: Maybe<String>;
  accountNumber_starts_with?: Maybe<String>;
  accountNumber_not_starts_with?: Maybe<String>;
  accountNumber_ends_with?: Maybe<String>;
  accountNumber_not_ends_with?: Maybe<String>;
  accountName?: Maybe<String>;
  accountName_not?: Maybe<String>;
  accountName_in?: Maybe<String[] | String>;
  accountName_not_in?: Maybe<String[] | String>;
  accountName_lt?: Maybe<String>;
  accountName_lte?: Maybe<String>;
  accountName_gt?: Maybe<String>;
  accountName_gte?: Maybe<String>;
  accountName_contains?: Maybe<String>;
  accountName_not_contains?: Maybe<String>;
  accountName_starts_with?: Maybe<String>;
  accountName_not_starts_with?: Maybe<String>;
  accountName_ends_with?: Maybe<String>;
  accountName_not_ends_with?: Maybe<String>;
  bankName?: Maybe<String>;
  bankName_not?: Maybe<String>;
  bankName_in?: Maybe<String[] | String>;
  bankName_not_in?: Maybe<String[] | String>;
  bankName_lt?: Maybe<String>;
  bankName_lte?: Maybe<String>;
  bankName_gt?: Maybe<String>;
  bankName_gte?: Maybe<String>;
  bankName_contains?: Maybe<String>;
  bankName_not_contains?: Maybe<String>;
  bankName_starts_with?: Maybe<String>;
  bankName_not_starts_with?: Maybe<String>;
  bankName_ends_with?: Maybe<String>;
  bankName_not_ends_with?: Maybe<String>;
  bankCode?: Maybe<String>;
  bankCode_not?: Maybe<String>;
  bankCode_in?: Maybe<String[] | String>;
  bankCode_not_in?: Maybe<String[] | String>;
  bankCode_lt?: Maybe<String>;
  bankCode_lte?: Maybe<String>;
  bankCode_gt?: Maybe<String>;
  bankCode_gte?: Maybe<String>;
  bankCode_contains?: Maybe<String>;
  bankCode_not_contains?: Maybe<String>;
  bankCode_starts_with?: Maybe<String>;
  bankCode_not_starts_with?: Maybe<String>;
  bankCode_ends_with?: Maybe<String>;
  bankCode_not_ends_with?: Maybe<String>;
  AND?: Maybe<BankWhereInput[] | BankWhereInput>;
  OR?: Maybe<BankWhereInput[] | BankWhereInput>;
  NOT?: Maybe<BankWhereInput[] | BankWhereInput>;
}

export interface ListingAvailabilityUpdateDataInput {
  from?: Maybe<String>;
  to?: Maybe<String>;
}

export interface AuthSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthWhereInput>;
  AND?: Maybe<AuthSubscriptionWhereInput[] | AuthSubscriptionWhereInput>;
  OR?: Maybe<AuthSubscriptionWhereInput[] | AuthSubscriptionWhereInput>;
  NOT?: Maybe<AuthSubscriptionWhereInput[] | AuthSubscriptionWhereInput>;
}

export interface ListingAvailabilityUpdateOneRequiredInput {
  create?: Maybe<ListingAvailabilityCreateInput>;
  update?: Maybe<ListingAvailabilityUpdateDataInput>;
  upsert?: Maybe<ListingAvailabilityUpsertNestedInput>;
  connect?: Maybe<ListingAvailabilityWhereUniqueInput>;
}

export type ListingAvailabilityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WarehouserIdentificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WarehouserIdentificationUpdateInput {
  idNumber?: Maybe<String>;
  expiryDate?: Maybe<String>;
  idType?: Maybe<String>;
}

export interface ListingProductsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface WallFinishesOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingProductsUpdateManyWithWhereNestedInput {
  where: ListingProductsScalarWhereInput;
  data: ListingProductsUpdateManyDataInput;
}

export type BankWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingProductsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ListingProductsScalarWhereInput[] | ListingProductsScalarWhereInput
  >;
  OR?: Maybe<
    ListingProductsScalarWhereInput[] | ListingProductsScalarWhereInput
  >;
  NOT?: Maybe<
    ListingProductsScalarWhereInput[] | ListingProductsScalarWhereInput
  >;
}

export interface ValueAddedServicesUpdateInput {
  slug?: Maybe<String>;
  default?: Maybe<Boolean>;
  name?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface ListingProductsUpsertWithWhereUniqueNestedInput {
  where: ListingProductsWhereUniqueInput;
  update: ListingProductsUpdateDataInput;
  create: ListingProductsCreateInput;
}

export type ListingPhotosWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrganizationUpdateOneRequiredInput {
  create?: Maybe<OrganizationCreateInput>;
  update?: Maybe<OrganizationUpdateDataInput>;
  upsert?: Maybe<OrganizationUpsertNestedInput>;
  connect?: Maybe<OrganizationWhereUniqueInput>;
}

export type ListingProductsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AmenitiesOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RoleUpdateOneRequiredInput {
  create?: Maybe<RoleCreateInput>;
  update?: Maybe<RoleUpdateDataInput>;
  upsert?: Maybe<RoleUpsertNestedInput>;
  connect?: Maybe<RoleWhereUniqueInput>;
}

export interface AmenitiesOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export type ListingRatingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AmenitiesOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RoleCreateOneInput {
  create?: Maybe<RoleCreateInput>;
  connect?: Maybe<RoleWhereUniqueInput>;
}

export interface ListingProductsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  dob?: Maybe<String>;
  terms?: Maybe<Boolean>;
  type?: Maybe<String>;
}

export interface ListingProductsUpdateWithWhereUniqueNestedInput {
  where: ListingProductsWhereUniqueInput;
  data: ListingProductsUpdateDataInput;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  dob?: Maybe<String>;
  terms?: Maybe<Boolean>;
  type?: Maybe<String>;
}

export interface AuthCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  phoneNumber: String;
  pin: String;
  userId: String;
  user: UserCreateOneInput;
}

export interface SuccessUpdateInput {
  success?: Maybe<Boolean>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SuccessCreateInput {
  id?: Maybe<ID_Input>;
  success: Boolean;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  phoneNumber: String;
  dob: String;
  terms?: Maybe<Boolean>;
  type: String;
}

export interface StatesUpdateInput {
  countryId?: Maybe<String>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface AuthUpdateInput {
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  pin?: Maybe<String>;
  userId?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export type LocationsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SpacesOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface UserUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  dob?: Maybe<String>;
  terms?: Maybe<Boolean>;
  type?: Maybe<String>;
}

export interface SelectOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface RoofingMaterialOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface AuthUpdateManyMutationInput {
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  pin?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface OrganizationWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  type?: Maybe<OrganizationTypeWhereInput>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  bank?: Maybe<BankWhereInput>;
  AND?: Maybe<OrganizationWhereInput[] | OrganizationWhereInput>;
  OR?: Maybe<OrganizationWhereInput[] | OrganizationWhereInput>;
  NOT?: Maybe<OrganizationWhereInput[] | OrganizationWhereInput>;
}

export interface BankCreateInput {
  id?: Maybe<ID_Input>;
  accountNumber: String;
  accountName: String;
  bankName: String;
  bankCode: String;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  dob?: Maybe<String>;
  dob_not?: Maybe<String>;
  dob_in?: Maybe<String[] | String>;
  dob_not_in?: Maybe<String[] | String>;
  dob_lt?: Maybe<String>;
  dob_lte?: Maybe<String>;
  dob_gt?: Maybe<String>;
  dob_gte?: Maybe<String>;
  dob_contains?: Maybe<String>;
  dob_not_contains?: Maybe<String>;
  dob_starts_with?: Maybe<String>;
  dob_not_starts_with?: Maybe<String>;
  dob_ends_with?: Maybe<String>;
  dob_not_ends_with?: Maybe<String>;
  terms?: Maybe<Boolean>;
  terms_not?: Maybe<Boolean>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface BankUpdateInput {
  accountNumber?: Maybe<String>;
  accountName?: Maybe<String>;
  bankName?: Maybe<String>;
  bankCode?: Maybe<String>;
}

export interface RoleUpdateInput {
  name?: Maybe<String>;
}

export interface BankUpdateManyMutationInput {
  accountNumber?: Maybe<String>;
  accountName?: Maybe<String>;
  bankName?: Maybe<String>;
  bankCode?: Maybe<String>;
}

export type OrganizationTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface CountriesCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface RequisitionDurationUpdateManyMutationInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
}

export interface CountriesUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface RequisitionCostUpdateManyMutationInput {
  baseCost?: Maybe<Float>;
  vat?: Maybe<Float>;
  discount?: Maybe<Float>;
}

export interface CountriesUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface RequisitionCostUpdateInput {
  baseCost?: Maybe<Float>;
  vat?: Maybe<Float>;
  discount?: Maybe<Float>;
}

export interface FloorsOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RequisitionUpdateManyMutationInput {
  expires?: Maybe<String>;
  space?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface FloorsOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingUpdateDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  description?: Maybe<String>;
  price?: Maybe<Float>;
  discount?: Maybe<Int>;
  currency?: Maybe<String>;
  proofOfOwnership?: Maybe<String>;
  identification?: Maybe<WarehouserIdentificationUpdateOneRequiredInput>;
  spacing?: Maybe<SpacesOptionsUpdateManyInput>;
  property?: Maybe<PropertiesOptionsUpdateManyInput>;
  floor?: Maybe<FloorsOptionsUpdateManyInput>;
  wallFinish?: Maybe<WallFinishesOptionsUpdateManyInput>;
  roofing?: Maybe<RoofingMaterialOptionsUpdateManyInput>;
  isSecure?: Maybe<SelectOptionsUpdateOneRequiredInput>;
  pest?: Maybe<SelectOptionsUpdateOneRequiredInput>;
  windows?: Maybe<Int>;
  location?: Maybe<LocationsUpdateOneRequiredInput>;
  amenities?: Maybe<AmenitiesOptionsUpdateManyInput>;
  avatar?: Maybe<String>;
  vas?: Maybe<ValueAddedServicesUpdateManyInput>;
  listingPhotos?: Maybe<ListingPhotosUpdateManyInput>;
  frequency?: Maybe<ListingsFrequenciesUpdateOneRequiredInput>;
  requirements?: Maybe<ListingRequirementsUpdateManyInput>;
  products?: Maybe<ListingProductsUpdateManyInput>;
  availability?: Maybe<ListingAvailabilityUpdateOneRequiredInput>;
  dimensions?: Maybe<ListingDimensionsUpdateOneRequiredInput>;
  status?: Maybe<Int>;
  rating?: Maybe<ListingRatingUpdateOneRequiredInput>;
}

export interface FloorsOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export type PropertiesOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IdentificationsOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RequisitionCostUpdateDataInput {
  baseCost?: Maybe<Float>;
  vat?: Maybe<Float>;
  discount?: Maybe<Float>;
}

export interface IdentificationsOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export type RatingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IdentificationsOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RatingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  listingId?: Maybe<String>;
  listingId_not?: Maybe<String>;
  listingId_in?: Maybe<String[] | String>;
  listingId_not_in?: Maybe<String[] | String>;
  listingId_lt?: Maybe<String>;
  listingId_lte?: Maybe<String>;
  listingId_gt?: Maybe<String>;
  listingId_gte?: Maybe<String>;
  listingId_contains?: Maybe<String>;
  listingId_not_contains?: Maybe<String>;
  listingId_starts_with?: Maybe<String>;
  listingId_not_starts_with?: Maybe<String>;
  listingId_ends_with?: Maybe<String>;
  listingId_not_ends_with?: Maybe<String>;
  ratingId?: Maybe<String>;
  ratingId_not?: Maybe<String>;
  ratingId_in?: Maybe<String[] | String>;
  ratingId_not_in?: Maybe<String[] | String>;
  ratingId_lt?: Maybe<String>;
  ratingId_lte?: Maybe<String>;
  ratingId_gt?: Maybe<String>;
  ratingId_gte?: Maybe<String>;
  ratingId_contains?: Maybe<String>;
  ratingId_not_contains?: Maybe<String>;
  ratingId_starts_with?: Maybe<String>;
  ratingId_not_starts_with?: Maybe<String>;
  ratingId_ends_with?: Maybe<String>;
  ratingId_not_ends_with?: Maybe<String>;
  rate?: Maybe<Int>;
  rate_not?: Maybe<Int>;
  rate_in?: Maybe<Int[] | Int>;
  rate_not_in?: Maybe<Int[] | Int>;
  rate_lt?: Maybe<Int>;
  rate_lte?: Maybe<Int>;
  rate_gt?: Maybe<Int>;
  rate_gte?: Maybe<Int>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<RatingWhereInput[] | RatingWhereInput>;
  OR?: Maybe<RatingWhereInput[] | RatingWhereInput>;
  NOT?: Maybe<RatingWhereInput[] | RatingWhereInput>;
}

export interface ListingCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  slug?: Maybe<String>;
  user: UserCreateOneInput;
  description: String;
  price: Float;
  discount?: Maybe<Int>;
  currency: String;
  proofOfOwnership: String;
  identification: WarehouserIdentificationCreateOneInput;
  spacing?: Maybe<SpacesOptionsCreateManyInput>;
  property?: Maybe<PropertiesOptionsCreateManyInput>;
  floor?: Maybe<FloorsOptionsCreateManyInput>;
  wallFinish?: Maybe<WallFinishesOptionsCreateManyInput>;
  roofing?: Maybe<RoofingMaterialOptionsCreateManyInput>;
  isSecure: SelectOptionsCreateOneInput;
  pest: SelectOptionsCreateOneInput;
  windows: Int;
  location: LocationsCreateOneInput;
  amenities?: Maybe<AmenitiesOptionsCreateManyInput>;
  avatar: String;
  vas?: Maybe<ValueAddedServicesCreateManyInput>;
  listingPhotos?: Maybe<ListingPhotosCreateManyInput>;
  frequency: ListingsFrequenciesCreateOneInput;
  requirements?: Maybe<ListingRequirementsCreateManyInput>;
  products?: Maybe<ListingProductsCreateManyInput>;
  availability: ListingAvailabilityCreateOneInput;
  dimensions: ListingDimensionsCreateOneInput;
  status: Int;
  rating: ListingRatingCreateOneInput;
}

export interface RequisitionDurationUpdateOneRequiredInput {
  create?: Maybe<RequisitionDurationCreateInput>;
  update?: Maybe<RequisitionDurationUpdateDataInput>;
  upsert?: Maybe<RequisitionDurationUpsertNestedInput>;
  connect?: Maybe<RequisitionDurationWhereUniqueInput>;
}

export interface WarehouserIdentificationCreateOneInput {
  create?: Maybe<WarehouserIdentificationCreateInput>;
  connect?: Maybe<WarehouserIdentificationWhereUniqueInput>;
}

export interface ListingCreateOneInput {
  create?: Maybe<ListingCreateInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface WarehouserIdentificationCreateInput {
  id?: Maybe<ID_Input>;
  idNumber: String;
  expiryDate: String;
  idType: String;
}

export interface RequisitionCostCreateInput {
  id?: Maybe<ID_Input>;
  baseCost: Float;
  vat: Float;
  discount?: Maybe<Float>;
}

export interface SpacesOptionsCreateManyInput {
  create?: Maybe<SpacesOptionsCreateInput[] | SpacesOptionsCreateInput>;
  connect?: Maybe<
    SpacesOptionsWhereUniqueInput[] | SpacesOptionsWhereUniqueInput
  >;
}

export interface RequisitionDurationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  slug?: Maybe<String>;
}

export interface SpacesOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RequisitionDurationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  AND?: Maybe<RequisitionDurationWhereInput[] | RequisitionDurationWhereInput>;
  OR?: Maybe<RequisitionDurationWhereInput[] | RequisitionDurationWhereInput>;
  NOT?: Maybe<RequisitionDurationWhereInput[] | RequisitionDurationWhereInput>;
}

export interface PropertiesOptionsCreateManyInput {
  create?: Maybe<PropertiesOptionsCreateInput[] | PropertiesOptionsCreateInput>;
  connect?: Maybe<
    PropertiesOptionsWhereUniqueInput[] | PropertiesOptionsWhereUniqueInput
  >;
}

export interface RequisitionDurationCreateOneInput {
  create?: Maybe<RequisitionDurationCreateInput>;
  connect?: Maybe<RequisitionDurationWhereUniqueInput>;
}

export interface PropertiesOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RatingUpdateManyMutationInput {
  listingId?: Maybe<String>;
  ratingId?: Maybe<String>;
  rate?: Maybe<Int>;
  userId?: Maybe<String>;
}

export interface FloorsOptionsCreateManyInput {
  create?: Maybe<FloorsOptionsCreateInput[] | FloorsOptionsCreateInput>;
  connect?: Maybe<
    FloorsOptionsWhereUniqueInput[] | FloorsOptionsWhereUniqueInput
  >;
}

export type RequisitionCostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WallFinishesOptionsCreateManyInput {
  create?: Maybe<
    WallFinishesOptionsCreateInput[] | WallFinishesOptionsCreateInput
  >;
  connect?: Maybe<
    WallFinishesOptionsWhereUniqueInput[] | WallFinishesOptionsWhereUniqueInput
  >;
}

export interface RatingCreateInput {
  id?: Maybe<ID_Input>;
  listingId: String;
  ratingId: String;
  rate: Int;
  userId: String;
}

export interface WallFinishesOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface PropertiesOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RoofingMaterialOptionsCreateManyInput {
  create?: Maybe<
    RoofingMaterialOptionsCreateInput[] | RoofingMaterialOptionsCreateInput
  >;
  connect?: Maybe<
    | RoofingMaterialOptionsWhereUniqueInput[]
    | RoofingMaterialOptionsWhereUniqueInput
  >;
}

export interface OtpUpdateManyMutationInput {
  phoneNumber?: Maybe<String>;
  code?: Maybe<String>;
  validated?: Maybe<Boolean>;
}

export interface RoofingMaterialOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface OtpCreateInput {
  id?: Maybe<ID_Input>;
  phoneNumber: String;
  code: String;
  validated: Boolean;
}

export interface SelectOptionsCreateOneInput {
  create?: Maybe<SelectOptionsCreateInput>;
  connect?: Maybe<SelectOptionsWhereUniqueInput>;
}

export type RoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface SelectOptionsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
}

export interface RoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RoleWhereInput[] | RoleWhereInput>;
  OR?: Maybe<RoleWhereInput[] | RoleWhereInput>;
  NOT?: Maybe<RoleWhereInput[] | RoleWhereInput>;
}

export interface LocationsCreateOneInput {
  create?: Maybe<LocationsCreateInput>;
  connect?: Maybe<LocationsWhereUniqueInput>;
}

export interface BankUpsertNestedInput {
  update: BankUpdateDataInput;
  create: BankCreateInput;
}

export interface LocationsCreateInput {
  id?: Maybe<ID_Input>;
  country: String;
  state?: Maybe<String>;
  geo?: Maybe<String>;
  lga?: Maybe<String>;
  street?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface BankUpdateOneRequiredInput {
  create?: Maybe<BankCreateInput>;
  update?: Maybe<BankUpdateDataInput>;
  upsert?: Maybe<BankUpsertNestedInput>;
  connect?: Maybe<BankWhereUniqueInput>;
}

export interface AmenitiesOptionsCreateManyInput {
  create?: Maybe<AmenitiesOptionsCreateInput[] | AmenitiesOptionsCreateInput>;
  connect?: Maybe<
    AmenitiesOptionsWhereUniqueInput[] | AmenitiesOptionsWhereUniqueInput
  >;
}

export interface OrganizationTypeUpsertNestedInput {
  update: OrganizationTypeUpdateDataInput;
  create: OrganizationTypeCreateInput;
}

export interface ValueAddedServicesCreateManyInput {
  create?: Maybe<
    ValueAddedServicesCreateInput[] | ValueAddedServicesCreateInput
  >;
  connect?: Maybe<
    ValueAddedServicesWhereUniqueInput[] | ValueAddedServicesWhereUniqueInput
  >;
}

export interface OrganizationTypeUpdateOneRequiredInput {
  create?: Maybe<OrganizationTypeCreateInput>;
  update?: Maybe<OrganizationTypeUpdateDataInput>;
  upsert?: Maybe<OrganizationTypeUpsertNestedInput>;
  connect?: Maybe<OrganizationTypeWhereUniqueInput>;
}

export interface ValueAddedServicesCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  default?: Maybe<Boolean>;
  name?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface OrganizationUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  type?: Maybe<OrganizationTypeUpdateOneRequiredInput>;
  phoneNumber?: Maybe<String>;
  bank?: Maybe<BankUpdateOneRequiredInput>;
}

export interface ListingPhotosCreateManyInput {
  create?: Maybe<ListingPhotosCreateInput[] | ListingPhotosCreateInput>;
  connect?: Maybe<
    ListingPhotosWhereUniqueInput[] | ListingPhotosWhereUniqueInput
  >;
}

export interface OrganizationTypeCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface ListingPhotosCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  default?: Maybe<Boolean>;
}

export type SpacesOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingsFrequenciesCreateOneInput {
  create?: Maybe<ListingsFrequenciesCreateInput>;
  connect?: Maybe<ListingsFrequenciesWhereUniqueInput>;
}

export interface LocationsUpdateManyMutationInput {
  country?: Maybe<String>;
  state?: Maybe<String>;
  geo?: Maybe<String>;
  lga?: Maybe<String>;
  street?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface ListingsFrequenciesCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export type StatesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingRequirementsCreateManyInput {
  create?: Maybe<
    ListingRequirementsCreateInput[] | ListingRequirementsCreateInput
  >;
  connect?: Maybe<
    ListingRequirementsWhereUniqueInput[] | ListingRequirementsWhereUniqueInput
  >;
}

export interface StatesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  countryId?: Maybe<String>;
  countryId_not?: Maybe<String>;
  countryId_in?: Maybe<String[] | String>;
  countryId_not_in?: Maybe<String[] | String>;
  countryId_lt?: Maybe<String>;
  countryId_lte?: Maybe<String>;
  countryId_gt?: Maybe<String>;
  countryId_gte?: Maybe<String>;
  countryId_contains?: Maybe<String>;
  countryId_not_contains?: Maybe<String>;
  countryId_starts_with?: Maybe<String>;
  countryId_not_starts_with?: Maybe<String>;
  countryId_ends_with?: Maybe<String>;
  countryId_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  AND?: Maybe<StatesWhereInput[] | StatesWhereInput>;
  OR?: Maybe<StatesWhereInput[] | StatesWhereInput>;
  NOT?: Maybe<StatesWhereInput[] | StatesWhereInput>;
}

export interface ListingRequirementsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface WallFinishesOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WallFinishesOptionsWhereInput>;
  AND?: Maybe<
    | WallFinishesOptionsSubscriptionWhereInput[]
    | WallFinishesOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | WallFinishesOptionsSubscriptionWhereInput[]
    | WallFinishesOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | WallFinishesOptionsSubscriptionWhereInput[]
    | WallFinishesOptionsSubscriptionWhereInput
  >;
}

export interface ListingProductsUpdateManyInput {
  create?: Maybe<ListingProductsCreateInput[] | ListingProductsCreateInput>;
  update?: Maybe<
    | ListingProductsUpdateWithWhereUniqueNestedInput[]
    | ListingProductsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ListingProductsUpsertWithWhereUniqueNestedInput[]
    | ListingProductsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ListingProductsWhereUniqueInput[] | ListingProductsWhereUniqueInput
  >;
  connect?: Maybe<
    ListingProductsWhereUniqueInput[] | ListingProductsWhereUniqueInput
  >;
  set?: Maybe<
    ListingProductsWhereUniqueInput[] | ListingProductsWhereUniqueInput
  >;
  disconnect?: Maybe<
    ListingProductsWhereUniqueInput[] | ListingProductsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ListingProductsScalarWhereInput[] | ListingProductsScalarWhereInput
  >;
  updateMany?: Maybe<
    | ListingProductsUpdateManyWithWhereNestedInput[]
    | ListingProductsUpdateManyWithWhereNestedInput
  >;
}

export interface IdentificationsOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    IdentificationsOptionsWhereInput[] | IdentificationsOptionsWhereInput
  >;
  OR?: Maybe<
    IdentificationsOptionsWhereInput[] | IdentificationsOptionsWhereInput
  >;
  NOT?: Maybe<
    IdentificationsOptionsWhereInput[] | IdentificationsOptionsWhereInput
  >;
}

export interface ListingProductsCreateInput {
  id?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface SpacesOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpacesOptionsWhereInput>;
  AND?: Maybe<
    SpacesOptionsSubscriptionWhereInput[] | SpacesOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    SpacesOptionsSubscriptionWhereInput[] | SpacesOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SpacesOptionsSubscriptionWhereInput[] | SpacesOptionsSubscriptionWhereInput
  >;
}

export interface ListingAvailabilityCreateOneInput {
  create?: Maybe<ListingAvailabilityCreateInput>;
  connect?: Maybe<ListingAvailabilityWhereUniqueInput>;
}

export interface RoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoleWhereInput>;
  AND?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
  OR?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
  NOT?: Maybe<RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput>;
}

export interface ListingAvailabilityCreateInput {
  id?: Maybe<ID_Input>;
  from: String;
  to: String;
}

export interface PropertiesOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<PropertiesOptionsWhereInput[] | PropertiesOptionsWhereInput>;
  OR?: Maybe<PropertiesOptionsWhereInput[] | PropertiesOptionsWhereInput>;
  NOT?: Maybe<PropertiesOptionsWhereInput[] | PropertiesOptionsWhereInput>;
}

export interface ListingDimensionsCreateOneInput {
  create?: Maybe<ListingDimensionsCreateInput>;
  connect?: Maybe<ListingDimensionsWhereUniqueInput>;
}

export interface CountriesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  AND?: Maybe<CountriesWhereInput[] | CountriesWhereInput>;
  OR?: Maybe<CountriesWhereInput[] | CountriesWhereInput>;
  NOT?: Maybe<CountriesWhereInput[] | CountriesWhereInput>;
}

export interface ListingDimensionsCreateInput {
  id?: Maybe<ID_Input>;
  height: Float;
  weight: Float;
  length: Float;
  unitOfDimensions?: Maybe<Int>;
  volume?: Maybe<Float>;
  area?: Maybe<Float>;
}

export interface OrganizationTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrganizationTypeWhereInput>;
  AND?: Maybe<
    | OrganizationTypeSubscriptionWhereInput[]
    | OrganizationTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OrganizationTypeSubscriptionWhereInput[]
    | OrganizationTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OrganizationTypeSubscriptionWhereInput[]
    | OrganizationTypeSubscriptionWhereInput
  >;
}

export interface ListingRatingCreateOneInput {
  create?: Maybe<ListingRatingCreateInput>;
  connect?: Maybe<ListingRatingWhereUniqueInput>;
}

export type CountriesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingRatingCreateInput {
  id?: Maybe<ID_Input>;
  count: Int;
  rates: Int;
  average: Float;
}

export interface ListingRatingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingRatingWhereInput>;
  AND?: Maybe<
    ListingRatingSubscriptionWhereInput[] | ListingRatingSubscriptionWhereInput
  >;
  OR?: Maybe<
    ListingRatingSubscriptionWhereInput[] | ListingRatingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ListingRatingSubscriptionWhereInput[] | ListingRatingSubscriptionWhereInput
  >;
}

export interface ListingUpdateInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  description?: Maybe<String>;
  price?: Maybe<Float>;
  discount?: Maybe<Int>;
  currency?: Maybe<String>;
  proofOfOwnership?: Maybe<String>;
  identification?: Maybe<WarehouserIdentificationUpdateOneRequiredInput>;
  spacing?: Maybe<SpacesOptionsUpdateManyInput>;
  property?: Maybe<PropertiesOptionsUpdateManyInput>;
  floor?: Maybe<FloorsOptionsUpdateManyInput>;
  wallFinish?: Maybe<WallFinishesOptionsUpdateManyInput>;
  roofing?: Maybe<RoofingMaterialOptionsUpdateManyInput>;
  isSecure?: Maybe<SelectOptionsUpdateOneRequiredInput>;
  pest?: Maybe<SelectOptionsUpdateOneRequiredInput>;
  windows?: Maybe<Int>;
  location?: Maybe<LocationsUpdateOneRequiredInput>;
  amenities?: Maybe<AmenitiesOptionsUpdateManyInput>;
  avatar?: Maybe<String>;
  vas?: Maybe<ValueAddedServicesUpdateManyInput>;
  listingPhotos?: Maybe<ListingPhotosUpdateManyInput>;
  frequency?: Maybe<ListingsFrequenciesUpdateOneRequiredInput>;
  requirements?: Maybe<ListingRequirementsUpdateManyInput>;
  products?: Maybe<ListingProductsUpdateManyInput>;
  availability?: Maybe<ListingAvailabilityUpdateOneRequiredInput>;
  dimensions?: Maybe<ListingDimensionsUpdateOneRequiredInput>;
  status?: Maybe<Int>;
  rating?: Maybe<ListingRatingUpdateOneRequiredInput>;
}

export interface ListingDimensionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingDimensionsWhereInput>;
  AND?: Maybe<
    | ListingDimensionsSubscriptionWhereInput[]
    | ListingDimensionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ListingDimensionsSubscriptionWhereInput[]
    | ListingDimensionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ListingDimensionsSubscriptionWhereInput[]
    | ListingDimensionsSubscriptionWhereInput
  >;
}

export interface WarehouserIdentificationUpdateOneRequiredInput {
  create?: Maybe<WarehouserIdentificationCreateInput>;
  update?: Maybe<WarehouserIdentificationUpdateDataInput>;
  upsert?: Maybe<WarehouserIdentificationUpsertNestedInput>;
  connect?: Maybe<WarehouserIdentificationWhereUniqueInput>;
}

export interface IdentificationsOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IdentificationsOptionsWhereInput>;
  AND?: Maybe<
    | IdentificationsOptionsSubscriptionWhereInput[]
    | IdentificationsOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | IdentificationsOptionsSubscriptionWhereInput[]
    | IdentificationsOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | IdentificationsOptionsSubscriptionWhereInput[]
    | IdentificationsOptionsSubscriptionWhereInput
  >;
}

export interface WarehouserIdentificationUpdateDataInput {
  idNumber?: Maybe<String>;
  expiryDate?: Maybe<String>;
  idType?: Maybe<String>;
}

export interface WarehouserIdentificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  idNumber?: Maybe<String>;
  idNumber_not?: Maybe<String>;
  idNumber_in?: Maybe<String[] | String>;
  idNumber_not_in?: Maybe<String[] | String>;
  idNumber_lt?: Maybe<String>;
  idNumber_lte?: Maybe<String>;
  idNumber_gt?: Maybe<String>;
  idNumber_gte?: Maybe<String>;
  idNumber_contains?: Maybe<String>;
  idNumber_not_contains?: Maybe<String>;
  idNumber_starts_with?: Maybe<String>;
  idNumber_not_starts_with?: Maybe<String>;
  idNumber_ends_with?: Maybe<String>;
  idNumber_not_ends_with?: Maybe<String>;
  expiryDate?: Maybe<String>;
  expiryDate_not?: Maybe<String>;
  expiryDate_in?: Maybe<String[] | String>;
  expiryDate_not_in?: Maybe<String[] | String>;
  expiryDate_lt?: Maybe<String>;
  expiryDate_lte?: Maybe<String>;
  expiryDate_gt?: Maybe<String>;
  expiryDate_gte?: Maybe<String>;
  expiryDate_contains?: Maybe<String>;
  expiryDate_not_contains?: Maybe<String>;
  expiryDate_starts_with?: Maybe<String>;
  expiryDate_not_starts_with?: Maybe<String>;
  expiryDate_ends_with?: Maybe<String>;
  expiryDate_not_ends_with?: Maybe<String>;
  idType?: Maybe<String>;
  idType_not?: Maybe<String>;
  idType_in?: Maybe<String[] | String>;
  idType_not_in?: Maybe<String[] | String>;
  idType_lt?: Maybe<String>;
  idType_lte?: Maybe<String>;
  idType_gt?: Maybe<String>;
  idType_gte?: Maybe<String>;
  idType_contains?: Maybe<String>;
  idType_not_contains?: Maybe<String>;
  idType_starts_with?: Maybe<String>;
  idType_not_starts_with?: Maybe<String>;
  idType_ends_with?: Maybe<String>;
  idType_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    WarehouserIdentificationWhereInput[] | WarehouserIdentificationWhereInput
  >;
  OR?: Maybe<
    WarehouserIdentificationWhereInput[] | WarehouserIdentificationWhereInput
  >;
  NOT?: Maybe<
    WarehouserIdentificationWhereInput[] | WarehouserIdentificationWhereInput
  >;
}

export interface WarehouserIdentificationUpsertNestedInput {
  update: WarehouserIdentificationUpdateDataInput;
  create: WarehouserIdentificationCreateInput;
}

export interface ListingAvailabilityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  from?: Maybe<String>;
  from_not?: Maybe<String>;
  from_in?: Maybe<String[] | String>;
  from_not_in?: Maybe<String[] | String>;
  from_lt?: Maybe<String>;
  from_lte?: Maybe<String>;
  from_gt?: Maybe<String>;
  from_gte?: Maybe<String>;
  from_contains?: Maybe<String>;
  from_not_contains?: Maybe<String>;
  from_starts_with?: Maybe<String>;
  from_not_starts_with?: Maybe<String>;
  from_ends_with?: Maybe<String>;
  from_not_ends_with?: Maybe<String>;
  to?: Maybe<String>;
  to_not?: Maybe<String>;
  to_in?: Maybe<String[] | String>;
  to_not_in?: Maybe<String[] | String>;
  to_lt?: Maybe<String>;
  to_lte?: Maybe<String>;
  to_gt?: Maybe<String>;
  to_gte?: Maybe<String>;
  to_contains?: Maybe<String>;
  to_not_contains?: Maybe<String>;
  to_starts_with?: Maybe<String>;
  to_not_starts_with?: Maybe<String>;
  to_ends_with?: Maybe<String>;
  to_not_ends_with?: Maybe<String>;
  AND?: Maybe<ListingAvailabilityWhereInput[] | ListingAvailabilityWhereInput>;
  OR?: Maybe<ListingAvailabilityWhereInput[] | ListingAvailabilityWhereInput>;
  NOT?: Maybe<ListingAvailabilityWhereInput[] | ListingAvailabilityWhereInput>;
}

export interface SpacesOptionsUpdateManyInput {
  create?: Maybe<SpacesOptionsCreateInput[] | SpacesOptionsCreateInput>;
  update?: Maybe<
    | SpacesOptionsUpdateWithWhereUniqueNestedInput[]
    | SpacesOptionsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SpacesOptionsUpsertWithWhereUniqueNestedInput[]
    | SpacesOptionsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    SpacesOptionsWhereUniqueInput[] | SpacesOptionsWhereUniqueInput
  >;
  connect?: Maybe<
    SpacesOptionsWhereUniqueInput[] | SpacesOptionsWhereUniqueInput
  >;
  set?: Maybe<SpacesOptionsWhereUniqueInput[] | SpacesOptionsWhereUniqueInput>;
  disconnect?: Maybe<
    SpacesOptionsWhereUniqueInput[] | SpacesOptionsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    SpacesOptionsScalarWhereInput[] | SpacesOptionsScalarWhereInput
  >;
  updateMany?: Maybe<
    | SpacesOptionsUpdateManyWithWhereNestedInput[]
    | SpacesOptionsUpdateManyWithWhereNestedInput
  >;
}

export interface BankSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BankWhereInput>;
  AND?: Maybe<BankSubscriptionWhereInput[] | BankSubscriptionWhereInput>;
  OR?: Maybe<BankSubscriptionWhereInput[] | BankSubscriptionWhereInput>;
  NOT?: Maybe<BankSubscriptionWhereInput[] | BankSubscriptionWhereInput>;
}

export interface SpacesOptionsUpdateWithWhereUniqueNestedInput {
  where: SpacesOptionsWhereUniqueInput;
  data: SpacesOptionsUpdateDataInput;
}

export interface WarehouserIdentificationUpdateManyMutationInput {
  idNumber?: Maybe<String>;
  expiryDate?: Maybe<String>;
  idType?: Maybe<String>;
}

export interface SpacesOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export type ListingDimensionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SpacesOptionsUpsertWithWhereUniqueNestedInput {
  where: SpacesOptionsWhereUniqueInput;
  update: SpacesOptionsUpdateDataInput;
  create: SpacesOptionsCreateInput;
}

export interface OrganizationUpsertNestedInput {
  update: OrganizationUpdateDataInput;
  create: OrganizationCreateInput;
}

export interface SpacesOptionsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<SpacesOptionsScalarWhereInput[] | SpacesOptionsScalarWhereInput>;
  OR?: Maybe<SpacesOptionsScalarWhereInput[] | SpacesOptionsScalarWhereInput>;
  NOT?: Maybe<SpacesOptionsScalarWhereInput[] | SpacesOptionsScalarWhereInput>;
}

export interface RoleUpsertNestedInput {
  update: RoleUpdateDataInput;
  create: RoleCreateInput;
}

export interface SpacesOptionsUpdateManyWithWhereNestedInput {
  where: SpacesOptionsScalarWhereInput;
  data: SpacesOptionsUpdateManyDataInput;
}

export interface UserOrganizationRoleUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  role?: Maybe<RoleUpdateOneRequiredInput>;
  organization?: Maybe<OrganizationUpdateOneRequiredInput>;
}

export interface FloorsOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<FloorsOptionsWhereInput[] | FloorsOptionsWhereInput>;
  OR?: Maybe<FloorsOptionsWhereInput[] | FloorsOptionsWhereInput>;
  NOT?: Maybe<FloorsOptionsWhereInput[] | FloorsOptionsWhereInput>;
}

export interface UserOrganizationRoleCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  role: RoleCreateOneInput;
  organization: OrganizationCreateOneInput;
}

export interface PropertiesOptionsUpdateManyInput {
  create?: Maybe<PropertiesOptionsCreateInput[] | PropertiesOptionsCreateInput>;
  update?: Maybe<
    | PropertiesOptionsUpdateWithWhereUniqueNestedInput[]
    | PropertiesOptionsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PropertiesOptionsUpsertWithWhereUniqueNestedInput[]
    | PropertiesOptionsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    PropertiesOptionsWhereUniqueInput[] | PropertiesOptionsWhereUniqueInput
  >;
  connect?: Maybe<
    PropertiesOptionsWhereUniqueInput[] | PropertiesOptionsWhereUniqueInput
  >;
  set?: Maybe<
    PropertiesOptionsWhereUniqueInput[] | PropertiesOptionsWhereUniqueInput
  >;
  disconnect?: Maybe<
    PropertiesOptionsWhereUniqueInput[] | PropertiesOptionsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    PropertiesOptionsScalarWhereInput[] | PropertiesOptionsScalarWhereInput
  >;
  updateMany?: Maybe<
    | PropertiesOptionsUpdateManyWithWhereNestedInput[]
    | PropertiesOptionsUpdateManyWithWhereNestedInput
  >;
}

export interface SuccessUpdateManyMutationInput {
  success?: Maybe<Boolean>;
}

export interface PropertiesOptionsUpdateWithWhereUniqueNestedInput {
  where: PropertiesOptionsWhereUniqueInput;
  data: PropertiesOptionsUpdateDataInput;
}

export interface StatesUpdateManyMutationInput {
  countryId?: Maybe<String>;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface PropertiesOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface SpacesOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface PropertiesOptionsUpsertWithWhereUniqueNestedInput {
  where: PropertiesOptionsWhereUniqueInput;
  update: PropertiesOptionsUpdateDataInput;
  create: PropertiesOptionsCreateInput;
}

export type OrganizationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PropertiesOptionsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PropertiesOptionsScalarWhereInput[] | PropertiesOptionsScalarWhereInput
  >;
  OR?: Maybe<
    PropertiesOptionsScalarWhereInput[] | PropertiesOptionsScalarWhereInput
  >;
  NOT?: Maybe<
    PropertiesOptionsScalarWhereInput[] | PropertiesOptionsScalarWhereInput
  >;
}

export interface OrganizationTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<OrganizationTypeWhereInput[] | OrganizationTypeWhereInput>;
  OR?: Maybe<OrganizationTypeWhereInput[] | OrganizationTypeWhereInput>;
  NOT?: Maybe<OrganizationTypeWhereInput[] | OrganizationTypeWhereInput>;
}

export interface PropertiesOptionsUpdateManyWithWhereNestedInput {
  where: PropertiesOptionsScalarWhereInput;
  data: PropertiesOptionsUpdateManyDataInput;
}

export interface RoleCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface PropertiesOptionsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RequisitionDurationUpdateInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
}

export interface FloorsOptionsUpdateManyInput {
  create?: Maybe<FloorsOptionsCreateInput[] | FloorsOptionsCreateInput>;
  update?: Maybe<
    | FloorsOptionsUpdateWithWhereUniqueNestedInput[]
    | FloorsOptionsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FloorsOptionsUpsertWithWhereUniqueNestedInput[]
    | FloorsOptionsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    FloorsOptionsWhereUniqueInput[] | FloorsOptionsWhereUniqueInput
  >;
  connect?: Maybe<
    FloorsOptionsWhereUniqueInput[] | FloorsOptionsWhereUniqueInput
  >;
  set?: Maybe<FloorsOptionsWhereUniqueInput[] | FloorsOptionsWhereUniqueInput>;
  disconnect?: Maybe<
    FloorsOptionsWhereUniqueInput[] | FloorsOptionsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    FloorsOptionsScalarWhereInput[] | FloorsOptionsScalarWhereInput
  >;
  updateMany?: Maybe<
    | FloorsOptionsUpdateManyWithWhereNestedInput[]
    | FloorsOptionsUpdateManyWithWhereNestedInput
  >;
}

export interface OtpWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  validated?: Maybe<Boolean>;
  validated_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OtpWhereInput[] | OtpWhereInput>;
  OR?: Maybe<OtpWhereInput[] | OtpWhereInput>;
  NOT?: Maybe<OtpWhereInput[] | OtpWhereInput>;
}

export interface FloorsOptionsUpdateWithWhereUniqueNestedInput {
  where: FloorsOptionsWhereUniqueInput;
  data: FloorsOptionsUpdateDataInput;
}

export interface ListingUpdateOneRequiredInput {
  create?: Maybe<ListingCreateInput>;
  update?: Maybe<ListingUpdateDataInput>;
  upsert?: Maybe<ListingUpsertNestedInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface FloorsOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RequisitionCostUpdateOneRequiredInput {
  create?: Maybe<RequisitionCostCreateInput>;
  update?: Maybe<RequisitionCostUpdateDataInput>;
  upsert?: Maybe<RequisitionCostUpsertNestedInput>;
  connect?: Maybe<RequisitionCostWhereUniqueInput>;
}

export interface FloorsOptionsUpsertWithWhereUniqueNestedInput {
  where: FloorsOptionsWhereUniqueInput;
  update: FloorsOptionsUpdateDataInput;
  create: FloorsOptionsCreateInput;
}

export interface RequisitionDurationUpdateDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
}

export interface FloorsOptionsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<FloorsOptionsScalarWhereInput[] | FloorsOptionsScalarWhereInput>;
  OR?: Maybe<FloorsOptionsScalarWhereInput[] | FloorsOptionsScalarWhereInput>;
  NOT?: Maybe<FloorsOptionsScalarWhereInput[] | FloorsOptionsScalarWhereInput>;
}

export type RequisitionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FloorsOptionsUpdateManyWithWhereNestedInput {
  where: FloorsOptionsScalarWhereInput;
  data: FloorsOptionsUpdateManyDataInput;
}

export interface RequisitionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  duration?: Maybe<RequisitionDurationWhereInput>;
  cost?: Maybe<RequisitionCostWhereInput>;
  user?: Maybe<UserWhereInput>;
  expires?: Maybe<String>;
  expires_not?: Maybe<String>;
  expires_in?: Maybe<String[] | String>;
  expires_not_in?: Maybe<String[] | String>;
  expires_lt?: Maybe<String>;
  expires_lte?: Maybe<String>;
  expires_gt?: Maybe<String>;
  expires_gte?: Maybe<String>;
  expires_contains?: Maybe<String>;
  expires_not_contains?: Maybe<String>;
  expires_starts_with?: Maybe<String>;
  expires_not_starts_with?: Maybe<String>;
  expires_ends_with?: Maybe<String>;
  expires_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ListingProductsWhereInput>;
  products_some?: Maybe<ListingProductsWhereInput>;
  products_none?: Maybe<ListingProductsWhereInput>;
  listing?: Maybe<ListingWhereInput>;
  space?: Maybe<Int>;
  space_not?: Maybe<Int>;
  space_in?: Maybe<Int[] | Int>;
  space_not_in?: Maybe<Int[] | Int>;
  space_lt?: Maybe<Int>;
  space_lte?: Maybe<Int>;
  space_gt?: Maybe<Int>;
  space_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  AND?: Maybe<RequisitionWhereInput[] | RequisitionWhereInput>;
  OR?: Maybe<RequisitionWhereInput[] | RequisitionWhereInput>;
  NOT?: Maybe<RequisitionWhereInput[] | RequisitionWhereInput>;
}

export interface FloorsOptionsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface RequisitionCreateInput {
  id?: Maybe<ID_Input>;
  duration: RequisitionDurationCreateOneInput;
  cost: RequisitionCostCreateOneInput;
  user: UserCreateOneInput;
  expires?: Maybe<String>;
  products?: Maybe<ListingProductsCreateManyInput>;
  listing: ListingCreateOneInput;
  space: Int;
  status: Int;
}

export interface WallFinishesOptionsUpdateManyInput {
  create?: Maybe<
    WallFinishesOptionsCreateInput[] | WallFinishesOptionsCreateInput
  >;
  update?: Maybe<
    | WallFinishesOptionsUpdateWithWhereUniqueNestedInput[]
    | WallFinishesOptionsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | WallFinishesOptionsUpsertWithWhereUniqueNestedInput[]
    | WallFinishesOptionsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    WallFinishesOptionsWhereUniqueInput[] | WallFinishesOptionsWhereUniqueInput
  >;
  connect?: Maybe<
    WallFinishesOptionsWhereUniqueInput[] | WallFinishesOptionsWhereUniqueInput
  >;
  set?: Maybe<
    WallFinishesOptionsWhereUniqueInput[] | WallFinishesOptionsWhereUniqueInput
  >;
  disconnect?: Maybe<
    WallFinishesOptionsWhereUniqueInput[] | WallFinishesOptionsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    WallFinishesOptionsScalarWhereInput[] | WallFinishesOptionsScalarWhereInput
  >;
  updateMany?: Maybe<
    | WallFinishesOptionsUpdateManyWithWhereNestedInput[]
    | WallFinishesOptionsUpdateManyWithWhereNestedInput
  >;
}

export type AuthWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
}>;

export interface WallFinishesOptionsUpdateWithWhereUniqueNestedInput {
  where: WallFinishesOptionsWhereUniqueInput;
  data: WallFinishesOptionsUpdateDataInput;
}

export type RequisitionDurationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WallFinishesOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface OrganizationTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface WallFinishesOptionsUpsertWithWhereUniqueNestedInput {
  where: WallFinishesOptionsWhereUniqueInput;
  update: WallFinishesOptionsUpdateDataInput;
  create: WallFinishesOptionsCreateInput;
}

export interface OrganizationUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumber?: Maybe<String>;
}

export interface WallFinishesOptionsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    WallFinishesOptionsScalarWhereInput[] | WallFinishesOptionsScalarWhereInput
  >;
  OR?: Maybe<
    WallFinishesOptionsScalarWhereInput[] | WallFinishesOptionsScalarWhereInput
  >;
  NOT?: Maybe<
    WallFinishesOptionsScalarWhereInput[] | WallFinishesOptionsScalarWhereInput
  >;
}

export type RoofingMaterialOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WallFinishesOptionsUpdateManyWithWhereNestedInput {
  where: WallFinishesOptionsScalarWhereInput;
  data: WallFinishesOptionsUpdateManyDataInput;
}

export type SelectOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WallFinishesOptionsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface OrganizationTypeCreateOneInput {
  create?: Maybe<OrganizationTypeCreateInput>;
  connect?: Maybe<OrganizationTypeWhereUniqueInput>;
}

export interface RoofingMaterialOptionsUpdateManyInput {
  create?: Maybe<
    RoofingMaterialOptionsCreateInput[] | RoofingMaterialOptionsCreateInput
  >;
  update?: Maybe<
    | RoofingMaterialOptionsUpdateWithWhereUniqueNestedInput[]
    | RoofingMaterialOptionsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RoofingMaterialOptionsUpsertWithWhereUniqueNestedInput[]
    | RoofingMaterialOptionsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | RoofingMaterialOptionsWhereUniqueInput[]
    | RoofingMaterialOptionsWhereUniqueInput
  >;
  connect?: Maybe<
    | RoofingMaterialOptionsWhereUniqueInput[]
    | RoofingMaterialOptionsWhereUniqueInput
  >;
  set?: Maybe<
    | RoofingMaterialOptionsWhereUniqueInput[]
    | RoofingMaterialOptionsWhereUniqueInput
  >;
  disconnect?: Maybe<
    | RoofingMaterialOptionsWhereUniqueInput[]
    | RoofingMaterialOptionsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | RoofingMaterialOptionsScalarWhereInput[]
    | RoofingMaterialOptionsScalarWhereInput
  >;
  updateMany?: Maybe<
    | RoofingMaterialOptionsUpdateManyWithWhereNestedInput[]
    | RoofingMaterialOptionsUpdateManyWithWhereNestedInput
  >;
}

export interface LocationsUpdateInput {
  country?: Maybe<String>;
  state?: Maybe<String>;
  geo?: Maybe<String>;
  lga?: Maybe<String>;
  street?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface RoofingMaterialOptionsUpdateWithWhereUniqueNestedInput {
  where: RoofingMaterialOptionsWhereUniqueInput;
  data: RoofingMaterialOptionsUpdateDataInput;
}

export type FloorsOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RoofingMaterialOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface SuccessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SuccessWhereInput>;
  AND?: Maybe<SuccessSubscriptionWhereInput[] | SuccessSubscriptionWhereInput>;
  OR?: Maybe<SuccessSubscriptionWhereInput[] | SuccessSubscriptionWhereInput>;
  NOT?: Maybe<SuccessSubscriptionWhereInput[] | SuccessSubscriptionWhereInput>;
}

export interface RoofingMaterialOptionsUpsertWithWhereUniqueNestedInput {
  where: RoofingMaterialOptionsWhereUniqueInput;
  update: RoofingMaterialOptionsUpdateDataInput;
  create: RoofingMaterialOptionsCreateInput;
}

export interface RequisitionDurationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequisitionDurationWhereInput>;
  AND?: Maybe<
    | RequisitionDurationSubscriptionWhereInput[]
    | RequisitionDurationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RequisitionDurationSubscriptionWhereInput[]
    | RequisitionDurationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RequisitionDurationSubscriptionWhereInput[]
    | RequisitionDurationSubscriptionWhereInput
  >;
}

export interface RoofingMaterialOptionsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | RoofingMaterialOptionsScalarWhereInput[]
    | RoofingMaterialOptionsScalarWhereInput
  >;
  OR?: Maybe<
    | RoofingMaterialOptionsScalarWhereInput[]
    | RoofingMaterialOptionsScalarWhereInput
  >;
  NOT?: Maybe<
    | RoofingMaterialOptionsScalarWhereInput[]
    | RoofingMaterialOptionsScalarWhereInput
  >;
}

export interface RoofingMaterialOptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    RoofingMaterialOptionsWhereInput[] | RoofingMaterialOptionsWhereInput
  >;
  OR?: Maybe<
    RoofingMaterialOptionsWhereInput[] | RoofingMaterialOptionsWhereInput
  >;
  NOT?: Maybe<
    RoofingMaterialOptionsWhereInput[] | RoofingMaterialOptionsWhereInput
  >;
}

export interface RoofingMaterialOptionsUpdateManyWithWhereNestedInput {
  where: RoofingMaterialOptionsScalarWhereInput;
  data: RoofingMaterialOptionsUpdateManyDataInput;
}

export interface ListingPhotosWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  AND?: Maybe<ListingPhotosWhereInput[] | ListingPhotosWhereInput>;
  OR?: Maybe<ListingPhotosWhereInput[] | ListingPhotosWhereInput>;
  NOT?: Maybe<ListingPhotosWhereInput[] | ListingPhotosWhereInput>;
}

export interface RoofingMaterialOptionsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingAvailabilitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingAvailabilityWhereInput>;
  AND?: Maybe<
    | ListingAvailabilitySubscriptionWhereInput[]
    | ListingAvailabilitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ListingAvailabilitySubscriptionWhereInput[]
    | ListingAvailabilitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ListingAvailabilitySubscriptionWhereInput[]
    | ListingAvailabilitySubscriptionWhereInput
  >;
}

export interface SelectOptionsUpdateOneRequiredInput {
  create?: Maybe<SelectOptionsCreateInput>;
  update?: Maybe<SelectOptionsUpdateDataInput>;
  upsert?: Maybe<SelectOptionsUpsertNestedInput>;
  connect?: Maybe<SelectOptionsWhereUniqueInput>;
}

export interface LocationsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  geo?: Maybe<String>;
  geo_not?: Maybe<String>;
  geo_in?: Maybe<String[] | String>;
  geo_not_in?: Maybe<String[] | String>;
  geo_lt?: Maybe<String>;
  geo_lte?: Maybe<String>;
  geo_gt?: Maybe<String>;
  geo_gte?: Maybe<String>;
  geo_contains?: Maybe<String>;
  geo_not_contains?: Maybe<String>;
  geo_starts_with?: Maybe<String>;
  geo_not_starts_with?: Maybe<String>;
  geo_ends_with?: Maybe<String>;
  geo_not_ends_with?: Maybe<String>;
  lga?: Maybe<String>;
  lga_not?: Maybe<String>;
  lga_in?: Maybe<String[] | String>;
  lga_not_in?: Maybe<String[] | String>;
  lga_lt?: Maybe<String>;
  lga_lte?: Maybe<String>;
  lga_gt?: Maybe<String>;
  lga_gte?: Maybe<String>;
  lga_contains?: Maybe<String>;
  lga_not_contains?: Maybe<String>;
  lga_starts_with?: Maybe<String>;
  lga_not_starts_with?: Maybe<String>;
  lga_ends_with?: Maybe<String>;
  lga_not_ends_with?: Maybe<String>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<LocationsWhereInput[] | LocationsWhereInput>;
  OR?: Maybe<LocationsWhereInput[] | LocationsWhereInput>;
  NOT?: Maybe<LocationsWhereInput[] | LocationsWhereInput>;
}

export interface SelectOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
}

export interface AmenitiesOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AmenitiesOptionsWhereInput>;
  AND?: Maybe<
    | AmenitiesOptionsSubscriptionWhereInput[]
    | AmenitiesOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AmenitiesOptionsSubscriptionWhereInput[]
    | AmenitiesOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AmenitiesOptionsSubscriptionWhereInput[]
    | AmenitiesOptionsSubscriptionWhereInput
  >;
}

export interface SelectOptionsUpsertNestedInput {
  update: SelectOptionsUpdateDataInput;
  create: SelectOptionsCreateInput;
}

export interface ValueAddedServicesUpdateManyMutationInput {
  slug?: Maybe<String>;
  default?: Maybe<Boolean>;
  name?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface LocationsUpdateOneRequiredInput {
  create?: Maybe<LocationsCreateInput>;
  update?: Maybe<LocationsUpdateDataInput>;
  upsert?: Maybe<LocationsUpsertNestedInput>;
  connect?: Maybe<LocationsWhereUniqueInput>;
}

export interface RoleUpdateDataInput {
  name?: Maybe<String>;
}

export interface LocationsUpdateDataInput {
  country?: Maybe<String>;
  state?: Maybe<String>;
  geo?: Maybe<String>;
  lga?: Maybe<String>;
  street?: Maybe<String>;
  userId?: Maybe<String>;
}

export type ListingRequirementsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LocationsUpsertNestedInput {
  update: LocationsUpdateDataInput;
  create: LocationsCreateInput;
}

export interface StatesCreateInput {
  id?: Maybe<ID_Input>;
  countryId: String;
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface AmenitiesOptionsUpdateManyInput {
  create?: Maybe<AmenitiesOptionsCreateInput[] | AmenitiesOptionsCreateInput>;
  update?: Maybe<
    | AmenitiesOptionsUpdateWithWhereUniqueNestedInput[]
    | AmenitiesOptionsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | AmenitiesOptionsUpsertWithWhereUniqueNestedInput[]
    | AmenitiesOptionsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    AmenitiesOptionsWhereUniqueInput[] | AmenitiesOptionsWhereUniqueInput
  >;
  connect?: Maybe<
    AmenitiesOptionsWhereUniqueInput[] | AmenitiesOptionsWhereUniqueInput
  >;
  set?: Maybe<
    AmenitiesOptionsWhereUniqueInput[] | AmenitiesOptionsWhereUniqueInput
  >;
  disconnect?: Maybe<
    AmenitiesOptionsWhereUniqueInput[] | AmenitiesOptionsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    AmenitiesOptionsScalarWhereInput[] | AmenitiesOptionsScalarWhereInput
  >;
  updateMany?: Maybe<
    | AmenitiesOptionsUpdateManyWithWhereNestedInput[]
    | AmenitiesOptionsUpdateManyWithWhereNestedInput
  >;
}

export interface RoofingMaterialOptionsUpdateInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface AmenitiesOptionsUpdateWithWhereUniqueNestedInput {
  where: AmenitiesOptionsWhereUniqueInput;
  data: AmenitiesOptionsUpdateDataInput;
}

export interface AuthWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  pin?: Maybe<String>;
  pin_not?: Maybe<String>;
  pin_in?: Maybe<String[] | String>;
  pin_not_in?: Maybe<String[] | String>;
  pin_lt?: Maybe<String>;
  pin_lte?: Maybe<String>;
  pin_gt?: Maybe<String>;
  pin_gte?: Maybe<String>;
  pin_contains?: Maybe<String>;
  pin_not_contains?: Maybe<String>;
  pin_starts_with?: Maybe<String>;
  pin_not_starts_with?: Maybe<String>;
  pin_ends_with?: Maybe<String>;
  pin_not_ends_with?: Maybe<String>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<AuthWhereInput[] | AuthWhereInput>;
  OR?: Maybe<AuthWhereInput[] | AuthWhereInput>;
  NOT?: Maybe<AuthWhereInput[] | AuthWhereInput>;
}

export interface AmenitiesOptionsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingUpsertNestedInput {
  update: ListingUpdateDataInput;
  create: ListingCreateInput;
}

export interface AmenitiesOptionsUpsertWithWhereUniqueNestedInput {
  where: AmenitiesOptionsWhereUniqueInput;
  update: AmenitiesOptionsUpdateDataInput;
  create: AmenitiesOptionsCreateInput;
}

export interface RequisitionDurationUpsertNestedInput {
  update: RequisitionDurationUpdateDataInput;
  create: RequisitionDurationCreateInput;
}

export interface AmenitiesOptionsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    AmenitiesOptionsScalarWhereInput[] | AmenitiesOptionsScalarWhereInput
  >;
  OR?: Maybe<
    AmenitiesOptionsScalarWhereInput[] | AmenitiesOptionsScalarWhereInput
  >;
  NOT?: Maybe<
    AmenitiesOptionsScalarWhereInput[] | AmenitiesOptionsScalarWhereInput
  >;
}

export interface RequisitionCostCreateOneInput {
  create?: Maybe<RequisitionCostCreateInput>;
  connect?: Maybe<RequisitionCostWhereUniqueInput>;
}

export interface AmenitiesOptionsUpdateManyWithWhereNestedInput {
  where: AmenitiesOptionsScalarWhereInput;
  data: AmenitiesOptionsUpdateManyDataInput;
}

export interface RatingUpdateInput {
  listingId?: Maybe<String>;
  ratingId?: Maybe<String>;
  rate?: Maybe<Int>;
  userId?: Maybe<String>;
}

export interface AmenitiesOptionsUpdateManyDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface OtpUpdateInput {
  phoneNumber?: Maybe<String>;
  code?: Maybe<String>;
  validated?: Maybe<Boolean>;
}

export interface ValueAddedServicesUpdateManyInput {
  create?: Maybe<
    ValueAddedServicesCreateInput[] | ValueAddedServicesCreateInput
  >;
  update?: Maybe<
    | ValueAddedServicesUpdateWithWhereUniqueNestedInput[]
    | ValueAddedServicesUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ValueAddedServicesUpsertWithWhereUniqueNestedInput[]
    | ValueAddedServicesUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ValueAddedServicesWhereUniqueInput[] | ValueAddedServicesWhereUniqueInput
  >;
  connect?: Maybe<
    ValueAddedServicesWhereUniqueInput[] | ValueAddedServicesWhereUniqueInput
  >;
  set?: Maybe<
    ValueAddedServicesWhereUniqueInput[] | ValueAddedServicesWhereUniqueInput
  >;
  disconnect?: Maybe<
    ValueAddedServicesWhereUniqueInput[] | ValueAddedServicesWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ValueAddedServicesScalarWhereInput[] | ValueAddedServicesScalarWhereInput
  >;
  updateMany?: Maybe<
    | ValueAddedServicesUpdateManyWithWhereNestedInput[]
    | ValueAddedServicesUpdateManyWithWhereNestedInput
  >;
}

export interface BankUpdateDataInput {
  accountNumber?: Maybe<String>;
  accountName?: Maybe<String>;
  bankName?: Maybe<String>;
  bankCode?: Maybe<String>;
}

export interface ValueAddedServicesUpdateWithWhereUniqueNestedInput {
  where: ValueAddedServicesWhereUniqueInput;
  data: ValueAddedServicesUpdateDataInput;
}

export interface BankCreateOneInput {
  create?: Maybe<BankCreateInput>;
  connect?: Maybe<BankWhereUniqueInput>;
}

export interface ValueAddedServicesUpdateDataInput {
  slug?: Maybe<String>;
  default?: Maybe<Boolean>;
  name?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface ListingsFrequenciesUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ValueAddedServicesUpsertWithWhereUniqueNestedInput {
  where: ValueAddedServicesWhereUniqueInput;
  update: ValueAddedServicesUpdateDataInput;
  create: ValueAddedServicesCreateInput;
}

export interface SelectOptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SelectOptionsWhereInput>;
  AND?: Maybe<
    SelectOptionsSubscriptionWhereInput[] | SelectOptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    SelectOptionsSubscriptionWhereInput[] | SelectOptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SelectOptionsSubscriptionWhereInput[] | SelectOptionsSubscriptionWhereInput
  >;
}

export interface ValueAddedServicesScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ValueAddedServicesScalarWhereInput[] | ValueAddedServicesScalarWhereInput
  >;
  OR?: Maybe<
    ValueAddedServicesScalarWhereInput[] | ValueAddedServicesScalarWhereInput
  >;
  NOT?: Maybe<
    ValueAddedServicesScalarWhereInput[] | ValueAddedServicesScalarWhereInput
  >;
}

export interface LocationsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationsWhereInput>;
  AND?: Maybe<
    LocationsSubscriptionWhereInput[] | LocationsSubscriptionWhereInput
  >;
  OR?: Maybe<
    LocationsSubscriptionWhereInput[] | LocationsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LocationsSubscriptionWhereInput[] | LocationsSubscriptionWhereInput
  >;
}

export interface ValueAddedServicesUpdateManyWithWhereNestedInput {
  where: ValueAddedServicesScalarWhereInput;
  data: ValueAddedServicesUpdateManyDataInput;
}

export interface CountriesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CountriesWhereInput>;
  AND?: Maybe<
    CountriesSubscriptionWhereInput[] | CountriesSubscriptionWhereInput
  >;
  OR?: Maybe<
    CountriesSubscriptionWhereInput[] | CountriesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CountriesSubscriptionWhereInput[] | CountriesSubscriptionWhereInput
  >;
}

export interface ValueAddedServicesUpdateManyDataInput {
  slug?: Maybe<String>;
  default?: Maybe<Boolean>;
  name?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface WallFinishesOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingPhotosUpdateManyInput {
  create?: Maybe<ListingPhotosCreateInput[] | ListingPhotosCreateInput>;
  update?: Maybe<
    | ListingPhotosUpdateWithWhereUniqueNestedInput[]
    | ListingPhotosUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ListingPhotosUpsertWithWhereUniqueNestedInput[]
    | ListingPhotosUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ListingPhotosWhereUniqueInput[] | ListingPhotosWhereUniqueInput
  >;
  connect?: Maybe<
    ListingPhotosWhereUniqueInput[] | ListingPhotosWhereUniqueInput
  >;
  set?: Maybe<ListingPhotosWhereUniqueInput[] | ListingPhotosWhereUniqueInput>;
  disconnect?: Maybe<
    ListingPhotosWhereUniqueInput[] | ListingPhotosWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ListingPhotosScalarWhereInput[] | ListingPhotosScalarWhereInput
  >;
  updateMany?: Maybe<
    | ListingPhotosUpdateManyWithWhereNestedInput[]
    | ListingPhotosUpdateManyWithWhereNestedInput
  >;
}

export interface OrganizationCreateOneInput {
  create?: Maybe<OrganizationCreateInput>;
  connect?: Maybe<OrganizationWhereUniqueInput>;
}

export interface ListingPhotosUpdateWithWhereUniqueNestedInput {
  where: ListingPhotosWhereUniqueInput;
  data: ListingPhotosUpdateDataInput;
}

export interface SelectOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
}

export interface ListingPhotosUpdateDataInput {
  url?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export type OtpWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  phoneNumber?: Maybe<String>;
}>;

export interface ListingPhotosUpsertWithWhereUniqueNestedInput {
  where: ListingPhotosWhereUniqueInput;
  update: ListingPhotosUpdateDataInput;
  create: ListingPhotosCreateInput;
}

export interface RequisitionUpdateInput {
  duration?: Maybe<RequisitionDurationUpdateOneRequiredInput>;
  cost?: Maybe<RequisitionCostUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  expires?: Maybe<String>;
  products?: Maybe<ListingProductsUpdateManyInput>;
  listing?: Maybe<ListingUpdateOneRequiredInput>;
  space?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface ListingPhotosScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  AND?: Maybe<ListingPhotosScalarWhereInput[] | ListingPhotosScalarWhereInput>;
  OR?: Maybe<ListingPhotosScalarWhereInput[] | ListingPhotosScalarWhereInput>;
  NOT?: Maybe<ListingPhotosScalarWhereInput[] | ListingPhotosScalarWhereInput>;
}

export interface PropertiesOptionsUpdateManyMutationInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface ListingPhotosUpdateManyWithWhereNestedInput {
  where: ListingPhotosScalarWhereInput;
  data: ListingPhotosUpdateManyDataInput;
}

export interface OrganizationTypeUpdateDataInput {
  name?: Maybe<String>;
}

export interface ListingPhotosUpdateManyDataInput {
  url?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export type IdentificationsOptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingsFrequenciesUpdateOneRequiredInput {
  create?: Maybe<ListingsFrequenciesCreateInput>;
  update?: Maybe<ListingsFrequenciesUpdateDataInput>;
  upsert?: Maybe<ListingsFrequenciesUpsertNestedInput>;
  connect?: Maybe<ListingsFrequenciesWhereUniqueInput>;
}

export interface ListingRequirementsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  AND?: Maybe<ListingRequirementsWhereInput[] | ListingRequirementsWhereInput>;
  OR?: Maybe<ListingRequirementsWhereInput[] | ListingRequirementsWhereInput>;
  NOT?: Maybe<ListingRequirementsWhereInput[] | ListingRequirementsWhereInput>;
}

export interface ListingsFrequenciesUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
  userId?: Maybe<String>;
}

export interface OrganizationUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  type?: Maybe<OrganizationTypeUpdateOneRequiredInput>;
  phoneNumber?: Maybe<String>;
  bank?: Maybe<BankUpdateOneRequiredInput>;
}

export interface ListingsFrequenciesUpsertNestedInput {
  update: ListingsFrequenciesUpdateDataInput;
  create: ListingsFrequenciesCreateInput;
}

export interface RoleUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ListingRequirementsUpdateManyInput {
  create?: Maybe<
    ListingRequirementsCreateInput[] | ListingRequirementsCreateInput
  >;
  update?: Maybe<
    | ListingRequirementsUpdateWithWhereUniqueNestedInput[]
    | ListingRequirementsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ListingRequirementsUpsertWithWhereUniqueNestedInput[]
    | ListingRequirementsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ListingRequirementsWhereUniqueInput[] | ListingRequirementsWhereUniqueInput
  >;
  connect?: Maybe<
    ListingRequirementsWhereUniqueInput[] | ListingRequirementsWhereUniqueInput
  >;
  set?: Maybe<
    ListingRequirementsWhereUniqueInput[] | ListingRequirementsWhereUniqueInput
  >;
  disconnect?: Maybe<
    ListingRequirementsWhereUniqueInput[] | ListingRequirementsWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ListingRequirementsScalarWhereInput[] | ListingRequirementsScalarWhereInput
  >;
  updateMany?: Maybe<
    | ListingRequirementsUpdateManyWithWhereNestedInput[]
    | ListingRequirementsUpdateManyWithWhereNestedInput
  >;
}

export interface RequisitionCostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  baseCost?: Maybe<Float>;
  baseCost_not?: Maybe<Float>;
  baseCost_in?: Maybe<Float[] | Float>;
  baseCost_not_in?: Maybe<Float[] | Float>;
  baseCost_lt?: Maybe<Float>;
  baseCost_lte?: Maybe<Float>;
  baseCost_gt?: Maybe<Float>;
  baseCost_gte?: Maybe<Float>;
  vat?: Maybe<Float>;
  vat_not?: Maybe<Float>;
  vat_in?: Maybe<Float[] | Float>;
  vat_not_in?: Maybe<Float[] | Float>;
  vat_lt?: Maybe<Float>;
  vat_lte?: Maybe<Float>;
  vat_gt?: Maybe<Float>;
  vat_gte?: Maybe<Float>;
  discount?: Maybe<Float>;
  discount_not?: Maybe<Float>;
  discount_in?: Maybe<Float[] | Float>;
  discount_not_in?: Maybe<Float[] | Float>;
  discount_lt?: Maybe<Float>;
  discount_lte?: Maybe<Float>;
  discount_gt?: Maybe<Float>;
  discount_gte?: Maybe<Float>;
  AND?: Maybe<RequisitionCostWhereInput[] | RequisitionCostWhereInput>;
  OR?: Maybe<RequisitionCostWhereInput[] | RequisitionCostWhereInput>;
  NOT?: Maybe<RequisitionCostWhereInput[] | RequisitionCostWhereInput>;
}

export interface ListingRequirementsUpdateWithWhereUniqueNestedInput {
  where: ListingRequirementsWhereUniqueInput;
  data: ListingRequirementsUpdateDataInput;
}

export interface OrganizationCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  email: String;
  type: OrganizationTypeCreateOneInput;
  phoneNumber: String;
  bank: BankCreateOneInput;
}

export interface ListingRequirementsUpdateManyWithWhereNestedInput {
  where: ListingRequirementsScalarWhereInput;
  data: ListingRequirementsUpdateManyDataInput;
}

export interface ListingRequirementsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  AND?: Maybe<
    ListingRequirementsScalarWhereInput[] | ListingRequirementsScalarWhereInput
  >;
  OR?: Maybe<
    ListingRequirementsScalarWhereInput[] | ListingRequirementsScalarWhereInput
  >;
  NOT?: Maybe<
    ListingRequirementsScalarWhereInput[] | ListingRequirementsScalarWhereInput
  >;
}

export interface ListingRequirementsUpsertWithWhereUniqueNestedInput {
  where: ListingRequirementsWhereUniqueInput;
  update: ListingRequirementsUpdateDataInput;
  create: ListingRequirementsCreateInput;
}

export interface ListingRequirementsUpdateDataInput {
  slug?: Maybe<String>;
  name?: Maybe<String>;
  default?: Maybe<Boolean>;
}

export interface RatingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RatingWhereInput>;
  AND?: Maybe<RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput>;
  OR?: Maybe<RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput>;
  NOT?: Maybe<RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput>;
}

export interface OrganizationTypeUpdateInput {
  name?: Maybe<String>;
}

export interface RequisitionCostUpsertNestedInput {
  update: RequisitionCostUpdateDataInput;
  create: RequisitionCostCreateInput;
}

export type ListingsFrequenciesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingRatingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  rates?: Maybe<Int>;
  rates_not?: Maybe<Int>;
  rates_in?: Maybe<Int[] | Int>;
  rates_not_in?: Maybe<Int[] | Int>;
  rates_lt?: Maybe<Int>;
  rates_lte?: Maybe<Int>;
  rates_gt?: Maybe<Int>;
  rates_gte?: Maybe<Int>;
  average?: Maybe<Float>;
  average_not?: Maybe<Float>;
  average_in?: Maybe<Float[] | Float>;
  average_not_in?: Maybe<Float[] | Float>;
  average_lt?: Maybe<Float>;
  average_lte?: Maybe<Float>;
  average_gt?: Maybe<Float>;
  average_gte?: Maybe<Float>;
  AND?: Maybe<ListingRatingWhereInput[] | ListingRatingWhereInput>;
  OR?: Maybe<ListingRatingWhereInput[] | ListingRatingWhereInput>;
  NOT?: Maybe<ListingRatingWhereInput[] | ListingRatingWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WarehouserIdentificationPreviousValues {
  id: ID_Output;
  idNumber: String;
  expiryDate: String;
  idType: String;
}

export interface WarehouserIdentificationPreviousValuesPromise
  extends Promise<WarehouserIdentificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idNumber: () => Promise<String>;
  expiryDate: () => Promise<String>;
  idType: () => Promise<String>;
}

export interface WarehouserIdentificationPreviousValuesSubscription
  extends Promise<AsyncIterator<WarehouserIdentificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  idNumber: () => Promise<AsyncIterator<String>>;
  expiryDate: () => Promise<AsyncIterator<String>>;
  idType: () => Promise<AsyncIterator<String>>;
}

export interface ListingAvailabilityEdge {
  node: ListingAvailability;
  cursor: String;
}

export interface ListingAvailabilityEdgePromise
  extends Promise<ListingAvailabilityEdge>,
    Fragmentable {
  node: <T = ListingAvailabilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingAvailabilityEdgeSubscription
  extends Promise<AsyncIterator<ListingAvailabilityEdge>>,
    Fragmentable {
  node: <T = ListingAvailabilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FloorsOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface FloorsOptionsPromise
  extends Promise<FloorsOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface FloorsOptionsSubscription
  extends Promise<AsyncIterator<FloorsOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface FloorsOptionsNullablePromise
  extends Promise<FloorsOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface ListingAvailabilityConnection {
  pageInfo: PageInfo;
  edges: ListingAvailabilityEdge[];
}

export interface ListingAvailabilityConnectionPromise
  extends Promise<ListingAvailabilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingAvailabilityEdge>>() => T;
  aggregate: <T = AggregateListingAvailabilityPromise>() => T;
}

export interface ListingAvailabilityConnectionSubscription
  extends Promise<AsyncIterator<ListingAvailabilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ListingAvailabilityEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateListingAvailabilitySubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Bank {
  id: ID_Output;
  accountNumber: String;
  accountName: String;
  bankName: String;
  bankCode: String;
}

export interface BankPromise extends Promise<Bank>, Fragmentable {
  id: () => Promise<ID_Output>;
  accountNumber: () => Promise<String>;
  accountName: () => Promise<String>;
  bankName: () => Promise<String>;
  bankCode: () => Promise<String>;
}

export interface BankSubscription
  extends Promise<AsyncIterator<Bank>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accountNumber: () => Promise<AsyncIterator<String>>;
  accountName: () => Promise<AsyncIterator<String>>;
  bankName: () => Promise<AsyncIterator<String>>;
  bankCode: () => Promise<AsyncIterator<String>>;
}

export interface BankNullablePromise
  extends Promise<Bank | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accountNumber: () => Promise<String>;
  accountName: () => Promise<String>;
  bankName: () => Promise<String>;
  bankCode: () => Promise<String>;
}

export interface WarehouserIdentificationEdge {
  node: WarehouserIdentification;
  cursor: String;
}

export interface WarehouserIdentificationEdgePromise
  extends Promise<WarehouserIdentificationEdge>,
    Fragmentable {
  node: <T = WarehouserIdentificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WarehouserIdentificationEdgeSubscription
  extends Promise<AsyncIterator<WarehouserIdentificationEdge>>,
    Fragmentable {
  node: <T = WarehouserIdentificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WallFinishesOptionsSubscriptionPayload {
  mutation: MutationType;
  node: WallFinishesOptions;
  updatedFields: String[];
  previousValues: WallFinishesOptionsPreviousValues;
}

export interface WallFinishesOptionsSubscriptionPayloadPromise
  extends Promise<WallFinishesOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WallFinishesOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WallFinishesOptionsPreviousValuesPromise>() => T;
}

export interface WallFinishesOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WallFinishesOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WallFinishesOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WallFinishesOptionsPreviousValuesSubscription>() => T;
}

export interface ValueAddedServicesPreviousValues {
  id: ID_Output;
  slug?: String;
  default?: Boolean;
  name?: String;
  userId?: String;
}

export interface ValueAddedServicesPreviousValuesPromise
  extends Promise<ValueAddedServicesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  default: () => Promise<Boolean>;
  name: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface ValueAddedServicesPreviousValuesSubscription
  extends Promise<AsyncIterator<ValueAddedServicesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWarehouserIdentification {
  count: Int;
}

export interface AggregateWarehouserIdentificationPromise
  extends Promise<AggregateWarehouserIdentification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWarehouserIdentificationSubscription
  extends Promise<AsyncIterator<AggregateWarehouserIdentification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateListing {
  count: Int;
}

export interface AggregateListingPromise
  extends Promise<AggregateListing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingSubscription
  extends Promise<AsyncIterator<AggregateListing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WarehouserIdentificationConnection {
  pageInfo: PageInfo;
  edges: WarehouserIdentificationEdge[];
}

export interface WarehouserIdentificationConnectionPromise
  extends Promise<WarehouserIdentificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WarehouserIdentificationEdge>>() => T;
  aggregate: <T = AggregateWarehouserIdentificationPromise>() => T;
}

export interface WarehouserIdentificationConnectionSubscription
  extends Promise<AsyncIterator<WarehouserIdentificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<WarehouserIdentificationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateWarehouserIdentificationSubscription>() => T;
}

export interface WallFinishesOptionsConnection {
  pageInfo: PageInfo;
  edges: WallFinishesOptionsEdge[];
}

export interface WallFinishesOptionsConnectionPromise
  extends Promise<WallFinishesOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WallFinishesOptionsEdge>>() => T;
  aggregate: <T = AggregateWallFinishesOptionsPromise>() => T;
}

export interface WallFinishesOptionsConnectionSubscription
  extends Promise<AsyncIterator<WallFinishesOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<WallFinishesOptionsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateWallFinishesOptionsSubscription>() => T;
}

export interface AggregateWallFinishesOptions {
  count: Int;
}

export interface AggregateWallFinishesOptionsPromise
  extends Promise<AggregateWallFinishesOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWallFinishesOptionsSubscription
  extends Promise<AsyncIterator<AggregateWallFinishesOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValueAddedServicesEdge {
  node: ValueAddedServices;
  cursor: String;
}

export interface ValueAddedServicesEdgePromise
  extends Promise<ValueAddedServicesEdge>,
    Fragmentable {
  node: <T = ValueAddedServicesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValueAddedServicesEdgeSubscription
  extends Promise<AsyncIterator<ValueAddedServicesEdge>>,
    Fragmentable {
  node: <T = ValueAddedServicesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AmenitiesOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface AmenitiesOptionsPromise
  extends Promise<AmenitiesOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AmenitiesOptionsSubscription
  extends Promise<AsyncIterator<AmenitiesOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AmenitiesOptionsNullablePromise
  extends Promise<AmenitiesOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AggregateUserOrganizationRole {
  count: Int;
}

export interface AggregateUserOrganizationRolePromise
  extends Promise<AggregateUserOrganizationRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserOrganizationRoleSubscription
  extends Promise<AsyncIterator<AggregateUserOrganizationRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesOptionsSubscriptionPayload {
  mutation: MutationType;
  node: AmenitiesOptions;
  updatedFields: String[];
  previousValues: AmenitiesOptionsPreviousValues;
}

export interface AmenitiesOptionsSubscriptionPayloadPromise
  extends Promise<AmenitiesOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AmenitiesOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AmenitiesOptionsPreviousValuesPromise>() => T;
}

export interface AmenitiesOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AmenitiesOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AmenitiesOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AmenitiesOptionsPreviousValuesSubscription>() => T;
}

export interface UserOrganizationRoleConnection {
  pageInfo: PageInfo;
  edges: UserOrganizationRoleEdge[];
}

export interface UserOrganizationRoleConnectionPromise
  extends Promise<UserOrganizationRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserOrganizationRoleEdge>>() => T;
  aggregate: <T = AggregateUserOrganizationRolePromise>() => T;
}

export interface UserOrganizationRoleConnectionSubscription
  extends Promise<AsyncIterator<UserOrganizationRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserOrganizationRoleEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserOrganizationRoleSubscription>() => T;
}

export interface AmenitiesOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface AmenitiesOptionsPreviousValuesPromise
  extends Promise<AmenitiesOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AmenitiesOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<AmenitiesOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface UserOrganizationRole {
  id: ID_Output;
}

export interface UserOrganizationRolePromise
  extends Promise<UserOrganizationRole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  role: <T = RolePromise>() => T;
  organization: <T = OrganizationPromise>() => T;
}

export interface UserOrganizationRoleSubscription
  extends Promise<AsyncIterator<UserOrganizationRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  role: <T = RoleSubscription>() => T;
  organization: <T = OrganizationSubscription>() => T;
}

export interface UserOrganizationRoleNullablePromise
  extends Promise<UserOrganizationRole | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  role: <T = RolePromise>() => T;
  organization: <T = OrganizationPromise>() => T;
}

export interface ListingEdge {
  node: Listing;
  cursor: String;
}

export interface ListingEdgePromise extends Promise<ListingEdge>, Fragmentable {
  node: <T = ListingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingEdgeSubscription
  extends Promise<AsyncIterator<ListingEdge>>,
    Fragmentable {
  node: <T = ListingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthSubscriptionPayload {
  mutation: MutationType;
  node: Auth;
  updatedFields: String[];
  previousValues: AuthPreviousValues;
}

export interface AuthSubscriptionPayloadPromise
  extends Promise<AuthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthPreviousValuesPromise>() => T;
}

export interface AuthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthPreviousValuesSubscription>() => T;
}

export interface AggregateSuccess {
  count: Int;
}

export interface AggregateSuccessPromise
  extends Promise<AggregateSuccess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSuccessSubscription
  extends Promise<AsyncIterator<AggregateSuccess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuthPreviousValues {
  id: ID_Output;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  phoneNumber: String;
  pin: String;
  userId: String;
}

export interface AuthPreviousValuesPromise
  extends Promise<AuthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phoneNumber: () => Promise<String>;
  pin: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface AuthPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface SuccessConnection {
  pageInfo: PageInfo;
  edges: SuccessEdge[];
}

export interface SuccessConnectionPromise
  extends Promise<SuccessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SuccessEdge>>() => T;
  aggregate: <T = AggregateSuccessPromise>() => T;
}

export interface SuccessConnectionSubscription
  extends Promise<AsyncIterator<SuccessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SuccessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSuccessSubscription>() => T;
}

export interface ListingConnection {
  pageInfo: PageInfo;
  edges: ListingEdge[];
}

export interface ListingConnectionPromise
  extends Promise<ListingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingEdge>>() => T;
  aggregate: <T = AggregateListingPromise>() => T;
}

export interface ListingConnectionSubscription
  extends Promise<AsyncIterator<ListingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingSubscription>() => T;
}

export interface Success {
  id: ID_Output;
  success: Boolean;
}

export interface SuccessPromise extends Promise<Success>, Fragmentable {
  id: () => Promise<ID_Output>;
  success: () => Promise<Boolean>;
}

export interface SuccessSubscription
  extends Promise<AsyncIterator<Success>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  success: () => Promise<AsyncIterator<Boolean>>;
}

export interface SuccessNullablePromise
  extends Promise<Success | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  success: () => Promise<Boolean>;
}

export interface BankSubscriptionPayload {
  mutation: MutationType;
  node: Bank;
  updatedFields: String[];
  previousValues: BankPreviousValues;
}

export interface BankSubscriptionPayloadPromise
  extends Promise<BankSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BankPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BankPreviousValuesPromise>() => T;
}

export interface BankSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BankSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BankSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BankPreviousValuesSubscription>() => T;
}

export interface StatesEdge {
  node: States;
  cursor: String;
}

export interface StatesEdgePromise extends Promise<StatesEdge>, Fragmentable {
  node: <T = StatesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StatesEdgeSubscription
  extends Promise<AsyncIterator<StatesEdge>>,
    Fragmentable {
  node: <T = StatesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BankPreviousValues {
  id: ID_Output;
  accountNumber: String;
  accountName: String;
  bankName: String;
  bankCode: String;
}

export interface BankPreviousValuesPromise
  extends Promise<BankPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  accountNumber: () => Promise<String>;
  accountName: () => Promise<String>;
  bankName: () => Promise<String>;
  bankCode: () => Promise<String>;
}

export interface BankPreviousValuesSubscription
  extends Promise<AsyncIterator<BankPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  accountNumber: () => Promise<AsyncIterator<String>>;
  accountName: () => Promise<AsyncIterator<String>>;
  bankName: () => Promise<AsyncIterator<String>>;
  bankCode: () => Promise<AsyncIterator<String>>;
}

export interface AmenitiesOptionsConnection {
  pageInfo: PageInfo;
  edges: AmenitiesOptionsEdge[];
}

export interface AmenitiesOptionsConnectionPromise
  extends Promise<AmenitiesOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AmenitiesOptionsEdge>>() => T;
  aggregate: <T = AggregateAmenitiesOptionsPromise>() => T;
}

export interface AmenitiesOptionsConnectionSubscription
  extends Promise<AsyncIterator<AmenitiesOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AmenitiesOptionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAmenitiesOptionsSubscription>() => T;
}

export interface ListingRating {
  id: ID_Output;
  count: Int;
  rates: Int;
  average: Float;
}

export interface ListingRatingPromise
  extends Promise<ListingRating>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  count: () => Promise<Int>;
  rates: () => Promise<Int>;
  average: () => Promise<Float>;
}

export interface ListingRatingSubscription
  extends Promise<AsyncIterator<ListingRating>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  count: () => Promise<AsyncIterator<Int>>;
  rates: () => Promise<AsyncIterator<Int>>;
  average: () => Promise<AsyncIterator<Float>>;
}

export interface ListingRatingNullablePromise
  extends Promise<ListingRating | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  count: () => Promise<Int>;
  rates: () => Promise<Int>;
  average: () => Promise<Float>;
}

export interface AggregateSpacesOptions {
  count: Int;
}

export interface AggregateSpacesOptionsPromise
  extends Promise<AggregateSpacesOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpacesOptionsSubscription
  extends Promise<AsyncIterator<AggregateSpacesOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CountriesSubscriptionPayload {
  mutation: MutationType;
  node: Countries;
  updatedFields: String[];
  previousValues: CountriesPreviousValues;
}

export interface CountriesSubscriptionPayloadPromise
  extends Promise<CountriesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountriesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountriesPreviousValuesPromise>() => T;
}

export interface CountriesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountriesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountriesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountriesPreviousValuesSubscription>() => T;
}

export interface SpacesOptionsConnection {
  pageInfo: PageInfo;
  edges: SpacesOptionsEdge[];
}

export interface SpacesOptionsConnectionPromise
  extends Promise<SpacesOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpacesOptionsEdge>>() => T;
  aggregate: <T = AggregateSpacesOptionsPromise>() => T;
}

export interface SpacesOptionsConnectionSubscription
  extends Promise<AsyncIterator<SpacesOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpacesOptionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpacesOptionsSubscription>() => T;
}

export interface CountriesPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
}

export interface CountriesPreviousValuesPromise
  extends Promise<CountriesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface CountriesPreviousValuesSubscription
  extends Promise<AsyncIterator<CountriesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface SelectOptionsEdge {
  node: SelectOptions;
  cursor: String;
}

export interface SelectOptionsEdgePromise
  extends Promise<SelectOptionsEdge>,
    Fragmentable {
  node: <T = SelectOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SelectOptionsEdgeSubscription
  extends Promise<AsyncIterator<SelectOptionsEdge>>,
    Fragmentable {
  node: <T = SelectOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingDimensions {
  id: ID_Output;
  height: Float;
  weight: Float;
  length: Float;
  unitOfDimensions?: Int;
  volume?: Float;
  area?: Float;
}

export interface ListingDimensionsPromise
  extends Promise<ListingDimensions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  height: () => Promise<Float>;
  weight: () => Promise<Float>;
  length: () => Promise<Float>;
  unitOfDimensions: () => Promise<Int>;
  volume: () => Promise<Float>;
  area: () => Promise<Float>;
}

export interface ListingDimensionsSubscription
  extends Promise<AsyncIterator<ListingDimensions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  height: () => Promise<AsyncIterator<Float>>;
  weight: () => Promise<AsyncIterator<Float>>;
  length: () => Promise<AsyncIterator<Float>>;
  unitOfDimensions: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Float>>;
  area: () => Promise<AsyncIterator<Float>>;
}

export interface ListingDimensionsNullablePromise
  extends Promise<ListingDimensions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  height: () => Promise<Float>;
  weight: () => Promise<Float>;
  length: () => Promise<Float>;
  unitOfDimensions: () => Promise<Int>;
  volume: () => Promise<Float>;
  area: () => Promise<Float>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface FloorsOptionsSubscriptionPayload {
  mutation: MutationType;
  node: FloorsOptions;
  updatedFields: String[];
  previousValues: FloorsOptionsPreviousValues;
}

export interface FloorsOptionsSubscriptionPayloadPromise
  extends Promise<FloorsOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FloorsOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FloorsOptionsPreviousValuesPromise>() => T;
}

export interface FloorsOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FloorsOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FloorsOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FloorsOptionsPreviousValuesSubscription>() => T;
}

export interface RoofingMaterialOptionsEdge {
  node: RoofingMaterialOptions;
  cursor: String;
}

export interface RoofingMaterialOptionsEdgePromise
  extends Promise<RoofingMaterialOptionsEdge>,
    Fragmentable {
  node: <T = RoofingMaterialOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoofingMaterialOptionsEdgeSubscription
  extends Promise<AsyncIterator<RoofingMaterialOptionsEdge>>,
    Fragmentable {
  node: <T = RoofingMaterialOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FloorsOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface FloorsOptionsPreviousValuesPromise
  extends Promise<FloorsOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface FloorsOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<FloorsOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRole {
  count: Int;
}

export interface AggregateRolePromise
  extends Promise<AggregateRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoleSubscription
  extends Promise<AsyncIterator<AggregateRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingAvailability {
  id: ID_Output;
  from: String;
  to: String;
}

export interface ListingAvailabilityPromise
  extends Promise<ListingAvailability>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: () => Promise<String>;
  to: () => Promise<String>;
}

export interface ListingAvailabilitySubscription
  extends Promise<AsyncIterator<ListingAvailability>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: () => Promise<AsyncIterator<String>>;
  to: () => Promise<AsyncIterator<String>>;
}

export interface ListingAvailabilityNullablePromise
  extends Promise<ListingAvailability | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: () => Promise<String>;
  to: () => Promise<String>;
}

export interface RoleConnection {
  pageInfo: PageInfo;
  edges: RoleEdge[];
}

export interface RoleConnectionPromise
  extends Promise<RoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoleEdge>>() => T;
  aggregate: <T = AggregateRolePromise>() => T;
}

export interface RoleConnectionSubscription
  extends Promise<AsyncIterator<RoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoleSubscription>() => T;
}

export interface IdentificationsOptionsSubscriptionPayload {
  mutation: MutationType;
  node: IdentificationsOptions;
  updatedFields: String[];
  previousValues: IdentificationsOptionsPreviousValues;
}

export interface IdentificationsOptionsSubscriptionPayloadPromise
  extends Promise<IdentificationsOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IdentificationsOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IdentificationsOptionsPreviousValuesPromise>() => T;
}

export interface IdentificationsOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IdentificationsOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IdentificationsOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IdentificationsOptionsPreviousValuesSubscription>() => T;
}

export interface Role {
  id: ID_Output;
  name?: String;
}

export interface RolePromise extends Promise<Role>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RoleSubscription
  extends Promise<AsyncIterator<Role>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoleNullablePromise
  extends Promise<Role | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface IdentificationsOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface IdentificationsOptionsPreviousValuesPromise
  extends Promise<IdentificationsOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface IdentificationsOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<IdentificationsOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionDurationEdge {
  node: RequisitionDuration;
  cursor: String;
}

export interface RequisitionDurationEdgePromise
  extends Promise<RequisitionDurationEdge>,
    Fragmentable {
  node: <T = RequisitionDurationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequisitionDurationEdgeSubscription
  extends Promise<AsyncIterator<RequisitionDurationEdge>>,
    Fragmentable {
  node: <T = RequisitionDurationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingProducts {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface ListingProductsPromise
  extends Promise<ListingProducts>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface ListingProductsSubscription
  extends Promise<AsyncIterator<ListingProducts>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface ListingProductsNullablePromise
  extends Promise<ListingProducts | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AggregateAmenitiesOptions {
  count: Int;
}

export interface AggregateAmenitiesOptionsPromise
  extends Promise<AggregateAmenitiesOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAmenitiesOptionsSubscription
  extends Promise<AsyncIterator<AggregateAmenitiesOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingSubscriptionPayload {
  mutation: MutationType;
  node: Listing;
  updatedFields: String[];
  previousValues: ListingPreviousValues;
}

export interface ListingSubscriptionPayloadPromise
  extends Promise<ListingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingPreviousValuesPromise>() => T;
}

export interface ListingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingPreviousValuesSubscription>() => T;
}

export interface RequisitionCostEdge {
  node: RequisitionCost;
  cursor: String;
}

export interface RequisitionCostEdgePromise
  extends Promise<RequisitionCostEdge>,
    Fragmentable {
  node: <T = RequisitionCostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequisitionCostEdgeSubscription
  extends Promise<AsyncIterator<RequisitionCostEdge>>,
    Fragmentable {
  node: <T = RequisitionCostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingPreviousValues {
  id: ID_Output;
  name?: String;
  slug?: String;
  description: String;
  price: Float;
  discount?: Int;
  currency: String;
  proofOfOwnership: String;
  windows: Int;
  avatar: String;
  status: Int;
}

export interface ListingPreviousValuesPromise
  extends Promise<ListingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  discount: () => Promise<Int>;
  currency: () => Promise<String>;
  proofOfOwnership: () => Promise<String>;
  windows: () => Promise<Int>;
  avatar: () => Promise<String>;
  status: () => Promise<Int>;
}

export interface ListingPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  discount: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<String>>;
  proofOfOwnership: () => Promise<AsyncIterator<String>>;
  windows: () => Promise<AsyncIterator<Int>>;
  avatar: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRequisition {
  count: Int;
}

export interface AggregateRequisitionPromise
  extends Promise<AggregateRequisition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequisitionSubscription
  extends Promise<AsyncIterator<AggregateRequisition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BankConnection {
  pageInfo: PageInfo;
  edges: BankEdge[];
}

export interface BankConnectionPromise
  extends Promise<BankConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BankEdge>>() => T;
  aggregate: <T = AggregateBankPromise>() => T;
}

export interface BankConnectionSubscription
  extends Promise<AsyncIterator<BankConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BankEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBankSubscription>() => T;
}

export interface RequisitionConnection {
  pageInfo: PageInfo;
  edges: RequisitionEdge[];
}

export interface RequisitionConnectionPromise
  extends Promise<RequisitionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequisitionEdge>>() => T;
  aggregate: <T = AggregateRequisitionPromise>() => T;
}

export interface RequisitionConnectionSubscription
  extends Promise<AsyncIterator<RequisitionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequisitionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequisitionSubscription>() => T;
}

export interface ListingAvailabilitySubscriptionPayload {
  mutation: MutationType;
  node: ListingAvailability;
  updatedFields: String[];
  previousValues: ListingAvailabilityPreviousValues;
}

export interface ListingAvailabilitySubscriptionPayloadPromise
  extends Promise<ListingAvailabilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingAvailabilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingAvailabilityPreviousValuesPromise>() => T;
}

export interface ListingAvailabilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingAvailabilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingAvailabilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingAvailabilityPreviousValuesSubscription>() => T;
}

export interface RequisitionCost {
  id: ID_Output;
  baseCost: Float;
  vat: Float;
  discount?: Float;
}

export interface RequisitionCostPromise
  extends Promise<RequisitionCost>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  baseCost: () => Promise<Float>;
  vat: () => Promise<Float>;
  discount: () => Promise<Float>;
}

export interface RequisitionCostSubscription
  extends Promise<AsyncIterator<RequisitionCost>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  baseCost: () => Promise<AsyncIterator<Float>>;
  vat: () => Promise<AsyncIterator<Float>>;
  discount: () => Promise<AsyncIterator<Float>>;
}

export interface RequisitionCostNullablePromise
  extends Promise<RequisitionCost | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  baseCost: () => Promise<Float>;
  vat: () => Promise<Float>;
  discount: () => Promise<Float>;
}

export interface ListingAvailabilityPreviousValues {
  id: ID_Output;
  from: String;
  to: String;
}

export interface ListingAvailabilityPreviousValuesPromise
  extends Promise<ListingAvailabilityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: () => Promise<String>;
  to: () => Promise<String>;
}

export interface ListingAvailabilityPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingAvailabilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: () => Promise<AsyncIterator<String>>;
  to: () => Promise<AsyncIterator<String>>;
}

export interface Requisition {
  id: ID_Output;
  expires?: String;
  space: Int;
  status: Int;
}

export interface RequisitionPromise extends Promise<Requisition>, Fragmentable {
  id: () => Promise<ID_Output>;
  duration: <T = RequisitionDurationPromise>() => T;
  cost: <T = RequisitionCostPromise>() => T;
  user: <T = UserPromise>() => T;
  expires: () => Promise<String>;
  products: <T = FragmentableArray<ListingProducts>>(args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  listing: <T = ListingPromise>() => T;
  space: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface RequisitionSubscription
  extends Promise<AsyncIterator<Requisition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  duration: <T = RequisitionDurationSubscription>() => T;
  cost: <T = RequisitionCostSubscription>() => T;
  user: <T = UserSubscription>() => T;
  expires: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ListingProductsSubscription>>>(args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  listing: <T = ListingSubscription>() => T;
  space: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface RequisitionNullablePromise
  extends Promise<Requisition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  duration: <T = RequisitionDurationPromise>() => T;
  cost: <T = RequisitionCostPromise>() => T;
  user: <T = UserPromise>() => T;
  expires: () => Promise<String>;
  products: <T = FragmentableArray<ListingProducts>>(args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  listing: <T = ListingPromise>() => T;
  space: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface ListingRequirements {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
}

export interface ListingRequirementsPromise
  extends Promise<ListingRequirements>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface ListingRequirementsSubscription
  extends Promise<AsyncIterator<ListingRequirements>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface ListingRequirementsNullablePromise
  extends Promise<ListingRequirements | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface RatingEdge {
  node: Rating;
  cursor: String;
}

export interface RatingEdgePromise extends Promise<RatingEdge>, Fragmentable {
  node: <T = RatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RatingEdgeSubscription
  extends Promise<AsyncIterator<RatingEdge>>,
    Fragmentable {
  node: <T = RatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingDimensionsSubscriptionPayload {
  mutation: MutationType;
  node: ListingDimensions;
  updatedFields: String[];
  previousValues: ListingDimensionsPreviousValues;
}

export interface ListingDimensionsSubscriptionPayloadPromise
  extends Promise<ListingDimensionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingDimensionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingDimensionsPreviousValuesPromise>() => T;
}

export interface ListingDimensionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingDimensionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingDimensionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingDimensionsPreviousValuesSubscription>() => T;
}

export interface WallFinishesOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface WallFinishesOptionsPreviousValuesPromise
  extends Promise<WallFinishesOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface WallFinishesOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<WallFinishesOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface ListingDimensionsPreviousValues {
  id: ID_Output;
  height: Float;
  weight: Float;
  length: Float;
  unitOfDimensions?: Int;
  volume?: Float;
  area?: Float;
}

export interface ListingDimensionsPreviousValuesPromise
  extends Promise<ListingDimensionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  height: () => Promise<Float>;
  weight: () => Promise<Float>;
  length: () => Promise<Float>;
  unitOfDimensions: () => Promise<Int>;
  volume: () => Promise<Float>;
  area: () => Promise<Float>;
}

export interface ListingDimensionsPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingDimensionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  height: () => Promise<AsyncIterator<Float>>;
  weight: () => Promise<AsyncIterator<Float>>;
  length: () => Promise<AsyncIterator<Float>>;
  unitOfDimensions: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Float>>;
  area: () => Promise<AsyncIterator<Float>>;
}

export interface AggregatePropertiesOptions {
  count: Int;
}

export interface AggregatePropertiesOptionsPromise
  extends Promise<AggregatePropertiesOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePropertiesOptionsSubscription
  extends Promise<AsyncIterator<AggregatePropertiesOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BankEdge {
  node: Bank;
  cursor: String;
}

export interface BankEdgePromise extends Promise<BankEdge>, Fragmentable {
  node: <T = BankPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BankEdgeSubscription
  extends Promise<AsyncIterator<BankEdge>>,
    Fragmentable {
  node: <T = BankSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PropertiesOptionsConnection {
  pageInfo: PageInfo;
  edges: PropertiesOptionsEdge[];
}

export interface PropertiesOptionsConnectionPromise
  extends Promise<PropertiesOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PropertiesOptionsEdge>>() => T;
  aggregate: <T = AggregatePropertiesOptionsPromise>() => T;
}

export interface PropertiesOptionsConnectionSubscription
  extends Promise<AsyncIterator<PropertiesOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PropertiesOptionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePropertiesOptionsSubscription>() => T;
}

export interface ListingPhotosSubscriptionPayload {
  mutation: MutationType;
  node: ListingPhotos;
  updatedFields: String[];
  previousValues: ListingPhotosPreviousValues;
}

export interface ListingPhotosSubscriptionPayloadPromise
  extends Promise<ListingPhotosSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingPhotosPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingPhotosPreviousValuesPromise>() => T;
}

export interface ListingPhotosSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingPhotosSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingPhotosSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingPhotosPreviousValuesSubscription>() => T;
}

export interface OtpEdge {
  node: Otp;
  cursor: String;
}

export interface OtpEdgePromise extends Promise<OtpEdge>, Fragmentable {
  node: <T = OtpPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OtpEdgeSubscription
  extends Promise<AsyncIterator<OtpEdge>>,
    Fragmentable {
  node: <T = OtpSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingPhotosPreviousValues {
  id: ID_Output;
  url: String;
  default?: Boolean;
}

export interface ListingPhotosPreviousValuesPromise
  extends Promise<ListingPhotosPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface ListingPhotosPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingPhotosPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  phoneNumber: String;
  dob: String;
  terms?: Boolean;
  type: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  dob: () => Promise<String>;
  terms: () => Promise<Boolean>;
  type: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<String>>;
  terms: () => Promise<AsyncIterator<Boolean>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  dob: () => Promise<String>;
  terms: () => Promise<Boolean>;
  type: () => Promise<String>;
}

export interface ListingsFrequencies {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface ListingsFrequenciesPromise
  extends Promise<ListingsFrequencies>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface ListingsFrequenciesSubscription
  extends Promise<AsyncIterator<ListingsFrequencies>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface ListingsFrequenciesNullablePromise
  extends Promise<ListingsFrequencies | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AggregateOrganizationType {
  count: Int;
}

export interface AggregateOrganizationTypePromise
  extends Promise<AggregateOrganizationType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrganizationTypeSubscription
  extends Promise<AsyncIterator<AggregateOrganizationType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingProductsSubscriptionPayload {
  mutation: MutationType;
  node: ListingProducts;
  updatedFields: String[];
  previousValues: ListingProductsPreviousValues;
}

export interface ListingProductsSubscriptionPayloadPromise
  extends Promise<ListingProductsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingProductsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingProductsPreviousValuesPromise>() => T;
}

export interface ListingProductsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingProductsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingProductsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingProductsPreviousValuesSubscription>() => T;
}

export interface OrganizationTypeConnection {
  pageInfo: PageInfo;
  edges: OrganizationTypeEdge[];
}

export interface OrganizationTypeConnectionPromise
  extends Promise<OrganizationTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrganizationTypeEdge>>() => T;
  aggregate: <T = AggregateOrganizationTypePromise>() => T;
}

export interface OrganizationTypeConnectionSubscription
  extends Promise<AsyncIterator<OrganizationTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrganizationTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrganizationTypeSubscription>() => T;
}

export interface ListingProductsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface ListingProductsPreviousValuesPromise
  extends Promise<ListingProductsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface ListingProductsPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingProductsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface OrganizationEdge {
  node: Organization;
  cursor: String;
}

export interface OrganizationEdgePromise
  extends Promise<OrganizationEdge>,
    Fragmentable {
  node: <T = OrganizationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrganizationEdgeSubscription
  extends Promise<AsyncIterator<OrganizationEdge>>,
    Fragmentable {
  node: <T = OrganizationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingPhotos {
  id: ID_Output;
  url: String;
  default?: Boolean;
}

export interface ListingPhotosPromise
  extends Promise<ListingPhotos>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface ListingPhotosSubscription
  extends Promise<AsyncIterator<ListingPhotos>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface ListingPhotosNullablePromise
  extends Promise<ListingPhotos | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface OrganizationType {
  id: ID_Output;
  name?: String;
}

export interface OrganizationTypePromise
  extends Promise<OrganizationType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OrganizationTypeSubscription
  extends Promise<AsyncIterator<OrganizationType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OrganizationTypeNullablePromise
  extends Promise<OrganizationType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ListingRatingSubscriptionPayload {
  mutation: MutationType;
  node: ListingRating;
  updatedFields: String[];
  previousValues: ListingRatingPreviousValues;
}

export interface ListingRatingSubscriptionPayloadPromise
  extends Promise<ListingRatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingRatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingRatingPreviousValuesPromise>() => T;
}

export interface ListingRatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingRatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingRatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingRatingPreviousValuesSubscription>() => T;
}

export interface AggregateLocations {
  count: Int;
}

export interface AggregateLocationsPromise
  extends Promise<AggregateLocations>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationsSubscription
  extends Promise<AsyncIterator<AggregateLocations>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingRatingPreviousValues {
  id: ID_Output;
  count: Int;
  rates: Int;
  average: Float;
}

export interface ListingRatingPreviousValuesPromise
  extends Promise<ListingRatingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  count: () => Promise<Int>;
  rates: () => Promise<Int>;
  average: () => Promise<Float>;
}

export interface ListingRatingPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingRatingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  count: () => Promise<AsyncIterator<Int>>;
  rates: () => Promise<AsyncIterator<Int>>;
  average: () => Promise<AsyncIterator<Float>>;
}

export interface LocationsConnection {
  pageInfo: PageInfo;
  edges: LocationsEdge[];
}

export interface LocationsConnectionPromise
  extends Promise<LocationsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationsEdge>>() => T;
  aggregate: <T = AggregateLocationsPromise>() => T;
}

export interface LocationsConnectionSubscription
  extends Promise<AsyncIterator<LocationsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationsSubscription>() => T;
}

export interface AggregateBank {
  count: Int;
}

export interface AggregateBankPromise
  extends Promise<AggregateBank>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBankSubscription
  extends Promise<AsyncIterator<AggregateBank>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateListingsFrequencies {
  count: Int;
}

export interface AggregateListingsFrequenciesPromise
  extends Promise<AggregateListingsFrequencies>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingsFrequenciesSubscription
  extends Promise<AsyncIterator<AggregateListingsFrequencies>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingRequirementsSubscriptionPayload {
  mutation: MutationType;
  node: ListingRequirements;
  updatedFields: String[];
  previousValues: ListingRequirementsPreviousValues;
}

export interface ListingRequirementsSubscriptionPayloadPromise
  extends Promise<ListingRequirementsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingRequirementsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingRequirementsPreviousValuesPromise>() => T;
}

export interface ListingRequirementsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingRequirementsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingRequirementsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingRequirementsPreviousValuesSubscription>() => T;
}

export interface ListingsFrequenciesConnection {
  pageInfo: PageInfo;
  edges: ListingsFrequenciesEdge[];
}

export interface ListingsFrequenciesConnectionPromise
  extends Promise<ListingsFrequenciesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingsFrequenciesEdge>>() => T;
  aggregate: <T = AggregateListingsFrequenciesPromise>() => T;
}

export interface ListingsFrequenciesConnectionSubscription
  extends Promise<AsyncIterator<ListingsFrequenciesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ListingsFrequenciesEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateListingsFrequenciesSubscription>() => T;
}

export interface ListingRequirementsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
}

export interface ListingRequirementsPreviousValuesPromise
  extends Promise<ListingRequirementsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface ListingRequirementsPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingRequirementsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateListingRequirements {
  count: Int;
}

export interface AggregateListingRequirementsPromise
  extends Promise<AggregateListingRequirements>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingRequirementsSubscription
  extends Promise<AsyncIterator<AggregateListingRequirements>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValueAddedServices {
  id: ID_Output;
  slug?: String;
  default?: Boolean;
  name?: String;
  userId?: String;
}

export interface ValueAddedServicesPromise
  extends Promise<ValueAddedServices>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  default: () => Promise<Boolean>;
  name: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface ValueAddedServicesSubscription
  extends Promise<AsyncIterator<ValueAddedServices>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface ValueAddedServicesNullablePromise
  extends Promise<ValueAddedServices | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  default: () => Promise<Boolean>;
  name: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface ListingRequirementsConnection {
  pageInfo: PageInfo;
  edges: ListingRequirementsEdge[];
}

export interface ListingRequirementsConnectionPromise
  extends Promise<ListingRequirementsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingRequirementsEdge>>() => T;
  aggregate: <T = AggregateListingRequirementsPromise>() => T;
}

export interface ListingRequirementsConnectionSubscription
  extends Promise<AsyncIterator<ListingRequirementsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ListingRequirementsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateListingRequirementsSubscription>() => T;
}

export interface ListingsFrequenciesSubscriptionPayload {
  mutation: MutationType;
  node: ListingsFrequencies;
  updatedFields: String[];
  previousValues: ListingsFrequenciesPreviousValues;
}

export interface ListingsFrequenciesSubscriptionPayloadPromise
  extends Promise<ListingsFrequenciesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingsFrequenciesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingsFrequenciesPreviousValuesPromise>() => T;
}

export interface ListingsFrequenciesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingsFrequenciesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingsFrequenciesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingsFrequenciesPreviousValuesSubscription>() => T;
}

export interface ListingRatingEdge {
  node: ListingRating;
  cursor: String;
}

export interface ListingRatingEdgePromise
  extends Promise<ListingRatingEdge>,
    Fragmentable {
  node: <T = ListingRatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingRatingEdgeSubscription
  extends Promise<AsyncIterator<ListingRatingEdge>>,
    Fragmentable {
  node: <T = ListingRatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingsFrequenciesPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface ListingsFrequenciesPreviousValuesPromise
  extends Promise<ListingsFrequenciesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface ListingsFrequenciesPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingsFrequenciesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAuth {
  count: Int;
}

export interface AggregateAuthPromise
  extends Promise<AggregateAuth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthSubscription
  extends Promise<AsyncIterator<AggregateAuth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Locations {
  id: ID_Output;
  country: String;
  state?: String;
  geo?: String;
  lga?: String;
  street?: String;
  userId?: String;
}

export interface LocationsPromise extends Promise<Locations>, Fragmentable {
  id: () => Promise<ID_Output>;
  country: () => Promise<String>;
  state: () => Promise<String>;
  geo: () => Promise<String>;
  lga: () => Promise<String>;
  street: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface LocationsSubscription
  extends Promise<AsyncIterator<Locations>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  country: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  geo: () => Promise<AsyncIterator<String>>;
  lga: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface LocationsNullablePromise
  extends Promise<Locations | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  country: () => Promise<String>;
  state: () => Promise<String>;
  geo: () => Promise<String>;
  lga: () => Promise<String>;
  street: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface ListingProductsEdge {
  node: ListingProducts;
  cursor: String;
}

export interface ListingProductsEdgePromise
  extends Promise<ListingProductsEdge>,
    Fragmentable {
  node: <T = ListingProductsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingProductsEdgeSubscription
  extends Promise<AsyncIterator<ListingProductsEdge>>,
    Fragmentable {
  node: <T = ListingProductsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationsSubscriptionPayload {
  mutation: MutationType;
  node: Locations;
  updatedFields: String[];
  previousValues: LocationsPreviousValues;
}

export interface LocationsSubscriptionPayloadPromise
  extends Promise<LocationsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationsPreviousValuesPromise>() => T;
}

export interface LocationsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationsPreviousValuesSubscription>() => T;
}

export interface AggregateListingPhotos {
  count: Int;
}

export interface AggregateListingPhotosPromise
  extends Promise<AggregateListingPhotos>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingPhotosSubscription
  extends Promise<AsyncIterator<AggregateListingPhotos>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationsPreviousValues {
  id: ID_Output;
  country: String;
  state?: String;
  geo?: String;
  lga?: String;
  street?: String;
  userId?: String;
}

export interface LocationsPreviousValuesPromise
  extends Promise<LocationsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  country: () => Promise<String>;
  state: () => Promise<String>;
  geo: () => Promise<String>;
  lga: () => Promise<String>;
  street: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface LocationsPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  country: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  geo: () => Promise<AsyncIterator<String>>;
  lga: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface ListingPhotosConnection {
  pageInfo: PageInfo;
  edges: ListingPhotosEdge[];
}

export interface ListingPhotosConnectionPromise
  extends Promise<ListingPhotosConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingPhotosEdge>>() => T;
  aggregate: <T = AggregateListingPhotosPromise>() => T;
}

export interface ListingPhotosConnectionSubscription
  extends Promise<AsyncIterator<ListingPhotosConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingPhotosEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingPhotosSubscription>() => T;
}

export interface SelectOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
}

export interface SelectOptionsPromise
  extends Promise<SelectOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SelectOptionsSubscription
  extends Promise<AsyncIterator<SelectOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SelectOptionsNullablePromise
  extends Promise<SelectOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ListingDimensionsEdge {
  node: ListingDimensions;
  cursor: String;
}

export interface ListingDimensionsEdgePromise
  extends Promise<ListingDimensionsEdge>,
    Fragmentable {
  node: <T = ListingDimensionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingDimensionsEdgeSubscription
  extends Promise<AsyncIterator<ListingDimensionsEdge>>,
    Fragmentable {
  node: <T = ListingDimensionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrganizationSubscriptionPayload {
  mutation: MutationType;
  node: Organization;
  updatedFields: String[];
  previousValues: OrganizationPreviousValues;
}

export interface OrganizationSubscriptionPayloadPromise
  extends Promise<OrganizationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrganizationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrganizationPreviousValuesPromise>() => T;
}

export interface OrganizationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrganizationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrganizationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrganizationPreviousValuesSubscription>() => T;
}

export interface AggregateListingAvailability {
  count: Int;
}

export interface AggregateListingAvailabilityPromise
  extends Promise<AggregateListingAvailability>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingAvailabilitySubscription
  extends Promise<AsyncIterator<AggregateListingAvailability>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrganizationPreviousValues {
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  id: ID_Output;
  name?: String;
  email: String;
  phoneNumber: String;
}

export interface OrganizationPreviousValuesPromise
  extends Promise<OrganizationPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
}

export interface OrganizationPreviousValuesSubscription
  extends Promise<AsyncIterator<OrganizationPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
}

export interface AggregateValueAddedServices {
  count: Int;
}

export interface AggregateValueAddedServicesPromise
  extends Promise<AggregateValueAddedServices>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValueAddedServicesSubscription
  extends Promise<AsyncIterator<AggregateValueAddedServices>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoofingMaterialOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface RoofingMaterialOptionsPromise
  extends Promise<RoofingMaterialOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface RoofingMaterialOptionsSubscription
  extends Promise<AsyncIterator<RoofingMaterialOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface RoofingMaterialOptionsNullablePromise
  extends Promise<RoofingMaterialOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface UserOrganizationRoleEdge {
  node: UserOrganizationRole;
  cursor: String;
}

export interface UserOrganizationRoleEdgePromise
  extends Promise<UserOrganizationRoleEdge>,
    Fragmentable {
  node: <T = UserOrganizationRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserOrganizationRoleEdgeSubscription
  extends Promise<AsyncIterator<UserOrganizationRoleEdge>>,
    Fragmentable {
  node: <T = UserOrganizationRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrganizationTypeSubscriptionPayload {
  mutation: MutationType;
  node: OrganizationType;
  updatedFields: String[];
  previousValues: OrganizationTypePreviousValues;
}

export interface OrganizationTypeSubscriptionPayloadPromise
  extends Promise<OrganizationTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrganizationTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrganizationTypePreviousValuesPromise>() => T;
}

export interface OrganizationTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrganizationTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrganizationTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrganizationTypePreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrganizationTypePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface OrganizationTypePreviousValuesPromise
  extends Promise<OrganizationTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface OrganizationTypePreviousValuesSubscription
  extends Promise<AsyncIterator<OrganizationTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SuccessEdge {
  node: Success;
  cursor: String;
}

export interface SuccessEdgePromise extends Promise<SuccessEdge>, Fragmentable {
  node: <T = SuccessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SuccessEdgeSubscription
  extends Promise<AsyncIterator<SuccessEdge>>,
    Fragmentable {
  node: <T = SuccessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Countries {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
}

export interface CountriesPromise extends Promise<Countries>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface CountriesSubscription
  extends Promise<AsyncIterator<Countries>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface CountriesNullablePromise
  extends Promise<Countries | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface AggregateStates {
  count: Int;
}

export interface AggregateStatesPromise
  extends Promise<AggregateStates>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStatesSubscription
  extends Promise<AsyncIterator<AggregateStates>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OtpSubscriptionPayload {
  mutation: MutationType;
  node: Otp;
  updatedFields: String[];
  previousValues: OtpPreviousValues;
}

export interface OtpSubscriptionPayloadPromise
  extends Promise<OtpSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OtpPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OtpPreviousValuesPromise>() => T;
}

export interface OtpSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OtpSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OtpSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OtpPreviousValuesSubscription>() => T;
}

export interface States {
  id: ID_Output;
  countryId: String;
  slug?: String;
  name?: String;
  default?: Boolean;
}

export interface StatesPromise extends Promise<States>, Fragmentable {
  id: () => Promise<ID_Output>;
  countryId: () => Promise<String>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface StatesSubscription
  extends Promise<AsyncIterator<States>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  countryId: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface StatesNullablePromise
  extends Promise<States | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  countryId: () => Promise<String>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface OtpPreviousValues {
  id: ID_Output;
  phoneNumber: String;
  code: String;
  validated: Boolean;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface OtpPreviousValuesPromise
  extends Promise<OtpPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  code: () => Promise<String>;
  validated: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OtpPreviousValuesSubscription
  extends Promise<AsyncIterator<OtpPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  validated: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSelectOptions {
  count: Int;
}

export interface AggregateSelectOptionsPromise
  extends Promise<AggregateSelectOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSelectOptionsSubscription
  extends Promise<AsyncIterator<AggregateSelectOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WallFinishesOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface WallFinishesOptionsPromise
  extends Promise<WallFinishesOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface WallFinishesOptionsSubscription
  extends Promise<AsyncIterator<WallFinishesOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface WallFinishesOptionsNullablePromise
  extends Promise<WallFinishesOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AggregateRoofingMaterialOptions {
  count: Int;
}

export interface AggregateRoofingMaterialOptionsPromise
  extends Promise<AggregateRoofingMaterialOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoofingMaterialOptionsSubscription
  extends Promise<AsyncIterator<AggregateRoofingMaterialOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PropertiesOptionsSubscriptionPayload {
  mutation: MutationType;
  node: PropertiesOptions;
  updatedFields: String[];
  previousValues: PropertiesOptionsPreviousValues;
}

export interface PropertiesOptionsSubscriptionPayloadPromise
  extends Promise<PropertiesOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PropertiesOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PropertiesOptionsPreviousValuesPromise>() => T;
}

export interface PropertiesOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PropertiesOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PropertiesOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PropertiesOptionsPreviousValuesSubscription>() => T;
}

export interface RoleEdge {
  node: Role;
  cursor: String;
}

export interface RoleEdgePromise extends Promise<RoleEdge>, Fragmentable {
  node: <T = RolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoleEdgeSubscription
  extends Promise<AsyncIterator<RoleEdge>>,
    Fragmentable {
  node: <T = RoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PropertiesOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface PropertiesOptionsPreviousValuesPromise
  extends Promise<PropertiesOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface PropertiesOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<PropertiesOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRequisitionDuration {
  count: Int;
}

export interface AggregateRequisitionDurationPromise
  extends Promise<AggregateRequisitionDuration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequisitionDurationSubscription
  extends Promise<AsyncIterator<AggregateRequisitionDuration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PropertiesOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface PropertiesOptionsPromise
  extends Promise<PropertiesOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface PropertiesOptionsSubscription
  extends Promise<AsyncIterator<PropertiesOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface PropertiesOptionsNullablePromise
  extends Promise<PropertiesOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface AggregateRequisitionCost {
  count: Int;
}

export interface AggregateRequisitionCostPromise
  extends Promise<AggregateRequisitionCost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequisitionCostSubscription
  extends Promise<AsyncIterator<AggregateRequisitionCost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RatingSubscriptionPayload {
  mutation: MutationType;
  node: Rating;
  updatedFields: String[];
  previousValues: RatingPreviousValues;
}

export interface RatingSubscriptionPayloadPromise
  extends Promise<RatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RatingPreviousValuesPromise>() => T;
}

export interface RatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RatingPreviousValuesSubscription>() => T;
}

export interface RequisitionEdge {
  node: Requisition;
  cursor: String;
}

export interface RequisitionEdgePromise
  extends Promise<RequisitionEdge>,
    Fragmentable {
  node: <T = RequisitionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequisitionEdgeSubscription
  extends Promise<AsyncIterator<RequisitionEdge>>,
    Fragmentable {
  node: <T = RequisitionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RatingPreviousValues {
  id: ID_Output;
  listingId: String;
  ratingId: String;
  rate: Int;
  userId: String;
}

export interface RatingPreviousValuesPromise
  extends Promise<RatingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  listingId: () => Promise<String>;
  ratingId: () => Promise<String>;
  rate: () => Promise<Int>;
  userId: () => Promise<String>;
}

export interface RatingPreviousValuesSubscription
  extends Promise<AsyncIterator<RatingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  listingId: () => Promise<AsyncIterator<String>>;
  ratingId: () => Promise<AsyncIterator<String>>;
  rate: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionDuration {
  id: ID_Output;
  name: String;
  slug?: String;
}

export interface RequisitionDurationPromise
  extends Promise<RequisitionDuration>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface RequisitionDurationSubscription
  extends Promise<AsyncIterator<RequisitionDuration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionDurationNullablePromise
  extends Promise<RequisitionDuration | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface CountriesConnection {
  pageInfo: PageInfo;
  edges: CountriesEdge[];
}

export interface CountriesConnectionPromise
  extends Promise<CountriesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountriesEdge>>() => T;
  aggregate: <T = AggregateCountriesPromise>() => T;
}

export interface CountriesConnectionSubscription
  extends Promise<AsyncIterator<CountriesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountriesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountriesSubscription>() => T;
}

export interface RatingConnection {
  pageInfo: PageInfo;
  edges: RatingEdge[];
}

export interface RatingConnectionPromise
  extends Promise<RatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RatingEdge>>() => T;
  aggregate: <T = AggregateRatingPromise>() => T;
}

export interface RatingConnectionSubscription
  extends Promise<AsyncIterator<RatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRatingSubscription>() => T;
}

export interface RequisitionSubscriptionPayload {
  mutation: MutationType;
  node: Requisition;
  updatedFields: String[];
  previousValues: RequisitionPreviousValues;
}

export interface RequisitionSubscriptionPayloadPromise
  extends Promise<RequisitionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequisitionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequisitionPreviousValuesPromise>() => T;
}

export interface RequisitionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequisitionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequisitionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequisitionPreviousValuesSubscription>() => T;
}

export interface PropertiesOptionsEdge {
  node: PropertiesOptions;
  cursor: String;
}

export interface PropertiesOptionsEdgePromise
  extends Promise<PropertiesOptionsEdge>,
    Fragmentable {
  node: <T = PropertiesOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PropertiesOptionsEdgeSubscription
  extends Promise<AsyncIterator<PropertiesOptionsEdge>>,
    Fragmentable {
  node: <T = PropertiesOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionPreviousValues {
  id: ID_Output;
  expires?: String;
  space: Int;
  status: Int;
}

export interface RequisitionPreviousValuesPromise
  extends Promise<RequisitionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  expires: () => Promise<String>;
  space: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface RequisitionPreviousValuesSubscription
  extends Promise<AsyncIterator<RequisitionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  expires: () => Promise<AsyncIterator<String>>;
  space: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface OtpConnection {
  pageInfo: PageInfo;
  edges: OtpEdge[];
}

export interface OtpConnectionPromise
  extends Promise<OtpConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OtpEdge>>() => T;
  aggregate: <T = AggregateOtpPromise>() => T;
}

export interface OtpConnectionSubscription
  extends Promise<AsyncIterator<OtpConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OtpEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOtpSubscription>() => T;
}

export interface SpacesOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface SpacesOptionsPromise
  extends Promise<SpacesOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface SpacesOptionsSubscription
  extends Promise<AsyncIterator<SpacesOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface SpacesOptionsNullablePromise
  extends Promise<SpacesOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface OrganizationTypeEdge {
  node: OrganizationType;
  cursor: String;
}

export interface OrganizationTypeEdgePromise
  extends Promise<OrganizationTypeEdge>,
    Fragmentable {
  node: <T = OrganizationTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrganizationTypeEdgeSubscription
  extends Promise<AsyncIterator<OrganizationTypeEdge>>,
    Fragmentable {
  node: <T = OrganizationTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionCostSubscriptionPayload {
  mutation: MutationType;
  node: RequisitionCost;
  updatedFields: String[];
  previousValues: RequisitionCostPreviousValues;
}

export interface RequisitionCostSubscriptionPayloadPromise
  extends Promise<RequisitionCostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequisitionCostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequisitionCostPreviousValuesPromise>() => T;
}

export interface RequisitionCostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequisitionCostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequisitionCostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequisitionCostPreviousValuesSubscription>() => T;
}

export interface OrganizationConnection {
  pageInfo: PageInfo;
  edges: OrganizationEdge[];
}

export interface OrganizationConnectionPromise
  extends Promise<OrganizationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrganizationEdge>>() => T;
  aggregate: <T = AggregateOrganizationPromise>() => T;
}

export interface OrganizationConnectionSubscription
  extends Promise<AsyncIterator<OrganizationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrganizationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrganizationSubscription>() => T;
}

export interface RequisitionCostPreviousValues {
  id: ID_Output;
  baseCost: Float;
  vat: Float;
  discount?: Float;
}

export interface RequisitionCostPreviousValuesPromise
  extends Promise<RequisitionCostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  baseCost: () => Promise<Float>;
  vat: () => Promise<Float>;
  discount: () => Promise<Float>;
}

export interface RequisitionCostPreviousValuesSubscription
  extends Promise<AsyncIterator<RequisitionCostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  baseCost: () => Promise<AsyncIterator<Float>>;
  vat: () => Promise<AsyncIterator<Float>>;
  discount: () => Promise<AsyncIterator<Float>>;
}

export interface LocationsEdge {
  node: Locations;
  cursor: String;
}

export interface LocationsEdgePromise
  extends Promise<LocationsEdge>,
    Fragmentable {
  node: <T = LocationsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationsEdgeSubscription
  extends Promise<AsyncIterator<LocationsEdge>>,
    Fragmentable {
  node: <T = LocationsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CountriesEdge {
  node: Countries;
  cursor: String;
}

export interface CountriesEdgePromise
  extends Promise<CountriesEdge>,
    Fragmentable {
  node: <T = CountriesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountriesEdgeSubscription
  extends Promise<AsyncIterator<CountriesEdge>>,
    Fragmentable {
  node: <T = CountriesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingsFrequenciesEdge {
  node: ListingsFrequencies;
  cursor: String;
}

export interface ListingsFrequenciesEdgePromise
  extends Promise<ListingsFrequenciesEdge>,
    Fragmentable {
  node: <T = ListingsFrequenciesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingsFrequenciesEdgeSubscription
  extends Promise<AsyncIterator<ListingsFrequenciesEdge>>,
    Fragmentable {
  node: <T = ListingsFrequenciesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionDurationSubscriptionPayload {
  mutation: MutationType;
  node: RequisitionDuration;
  updatedFields: String[];
  previousValues: RequisitionDurationPreviousValues;
}

export interface RequisitionDurationSubscriptionPayloadPromise
  extends Promise<RequisitionDurationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequisitionDurationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequisitionDurationPreviousValuesPromise>() => T;
}

export interface RequisitionDurationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequisitionDurationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequisitionDurationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequisitionDurationPreviousValuesSubscription>() => T;
}

export interface ListingRequirementsEdge {
  node: ListingRequirements;
  cursor: String;
}

export interface ListingRequirementsEdgePromise
  extends Promise<ListingRequirementsEdge>,
    Fragmentable {
  node: <T = ListingRequirementsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingRequirementsEdgeSubscription
  extends Promise<AsyncIterator<ListingRequirementsEdge>>,
    Fragmentable {
  node: <T = ListingRequirementsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequisitionDurationPreviousValues {
  id: ID_Output;
  name: String;
  slug?: String;
}

export interface RequisitionDurationPreviousValuesPromise
  extends Promise<RequisitionDurationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface RequisitionDurationPreviousValuesSubscription
  extends Promise<AsyncIterator<RequisitionDurationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface ListingRatingConnection {
  pageInfo: PageInfo;
  edges: ListingRatingEdge[];
}

export interface ListingRatingConnectionPromise
  extends Promise<ListingRatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingRatingEdge>>() => T;
  aggregate: <T = AggregateListingRatingPromise>() => T;
}

export interface ListingRatingConnectionSubscription
  extends Promise<AsyncIterator<ListingRatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingRatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingRatingSubscription>() => T;
}

export interface WarehouserIdentification {
  id: ID_Output;
  idNumber: String;
  expiryDate: String;
  idType: String;
}

export interface WarehouserIdentificationPromise
  extends Promise<WarehouserIdentification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idNumber: () => Promise<String>;
  expiryDate: () => Promise<String>;
  idType: () => Promise<String>;
}

export interface WarehouserIdentificationSubscription
  extends Promise<AsyncIterator<WarehouserIdentification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  idNumber: () => Promise<AsyncIterator<String>>;
  expiryDate: () => Promise<AsyncIterator<String>>;
  idType: () => Promise<AsyncIterator<String>>;
}

export interface WarehouserIdentificationNullablePromise
  extends Promise<WarehouserIdentification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idNumber: () => Promise<String>;
  expiryDate: () => Promise<String>;
  idType: () => Promise<String>;
}

export interface ListingProductsConnection {
  pageInfo: PageInfo;
  edges: ListingProductsEdge[];
}

export interface ListingProductsConnectionPromise
  extends Promise<ListingProductsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingProductsEdge>>() => T;
  aggregate: <T = AggregateListingProductsPromise>() => T;
}

export interface ListingProductsConnectionSubscription
  extends Promise<AsyncIterator<ListingProductsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingProductsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingProductsSubscription>() => T;
}

export interface RoleSubscriptionPayload {
  mutation: MutationType;
  node: Role;
  updatedFields: String[];
  previousValues: RolePreviousValues;
}

export interface RoleSubscriptionPayloadPromise
  extends Promise<RoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RolePreviousValuesPromise>() => T;
}

export interface RoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RolePreviousValuesSubscription>() => T;
}

export interface AggregateListingDimensions {
  count: Int;
}

export interface AggregateListingDimensionsPromise
  extends Promise<AggregateListingDimensions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingDimensionsSubscription
  extends Promise<AsyncIterator<AggregateListingDimensions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RolePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface RolePreviousValuesPromise
  extends Promise<RolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RolePreviousValuesSubscription
  extends Promise<AsyncIterator<RolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface WallFinishesOptionsEdge {
  node: WallFinishesOptions;
  cursor: String;
}

export interface WallFinishesOptionsEdgePromise
  extends Promise<WallFinishesOptionsEdge>,
    Fragmentable {
  node: <T = WallFinishesOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WallFinishesOptionsEdgeSubscription
  extends Promise<AsyncIterator<WallFinishesOptionsEdge>>,
    Fragmentable {
  node: <T = WallFinishesOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FloorsOptionsEdge {
  node: FloorsOptions;
  cursor: String;
}

export interface FloorsOptionsEdgePromise
  extends Promise<FloorsOptionsEdge>,
    Fragmentable {
  node: <T = FloorsOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FloorsOptionsEdgeSubscription
  extends Promise<AsyncIterator<FloorsOptionsEdge>>,
    Fragmentable {
  node: <T = FloorsOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WarehouserIdentificationSubscriptionPayload {
  mutation: MutationType;
  node: WarehouserIdentification;
  updatedFields: String[];
  previousValues: WarehouserIdentificationPreviousValues;
}

export interface WarehouserIdentificationSubscriptionPayloadPromise
  extends Promise<WarehouserIdentificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WarehouserIdentificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WarehouserIdentificationPreviousValuesPromise>() => T;
}

export interface WarehouserIdentificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WarehouserIdentificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WarehouserIdentificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = WarehouserIdentificationPreviousValuesSubscription
  >() => T;
}

export interface RoofingMaterialOptionsSubscriptionPayload {
  mutation: MutationType;
  node: RoofingMaterialOptions;
  updatedFields: String[];
  previousValues: RoofingMaterialOptionsPreviousValues;
}

export interface RoofingMaterialOptionsSubscriptionPayloadPromise
  extends Promise<RoofingMaterialOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoofingMaterialOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoofingMaterialOptionsPreviousValuesPromise>() => T;
}

export interface RoofingMaterialOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoofingMaterialOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoofingMaterialOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoofingMaterialOptionsPreviousValuesSubscription>() => T;
}

export interface FloorsOptionsConnection {
  pageInfo: PageInfo;
  edges: FloorsOptionsEdge[];
}

export interface FloorsOptionsConnectionPromise
  extends Promise<FloorsOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FloorsOptionsEdge>>() => T;
  aggregate: <T = AggregateFloorsOptionsPromise>() => T;
}

export interface FloorsOptionsConnectionSubscription
  extends Promise<AsyncIterator<FloorsOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FloorsOptionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFloorsOptionsSubscription>() => T;
}

export interface RoofingMaterialOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface RoofingMaterialOptionsPreviousValuesPromise
  extends Promise<RoofingMaterialOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface RoofingMaterialOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<RoofingMaterialOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface SpacesOptionsEdge {
  node: SpacesOptions;
  cursor: String;
}

export interface SpacesOptionsEdgePromise
  extends Promise<SpacesOptionsEdge>,
    Fragmentable {
  node: <T = SpacesOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpacesOptionsEdgeSubscription
  extends Promise<AsyncIterator<SpacesOptionsEdge>>,
    Fragmentable {
  node: <T = SpacesOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Listing {
  id: ID_Output;
  name?: String;
  slug?: String;
  description: String;
  price: Float;
  discount?: Int;
  currency: String;
  proofOfOwnership: String;
  windows: Int;
  avatar: String;
  status: Int;
}

export interface ListingPromise extends Promise<Listing>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  user: <T = UserPromise>() => T;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  discount: () => Promise<Int>;
  currency: () => Promise<String>;
  proofOfOwnership: () => Promise<String>;
  identification: <T = WarehouserIdentificationPromise>() => T;
  spacing: <T = FragmentableArray<SpacesOptions>>(args?: {
    where?: SpacesOptionsWhereInput;
    orderBy?: SpacesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  property: <T = FragmentableArray<PropertiesOptions>>(args?: {
    where?: PropertiesOptionsWhereInput;
    orderBy?: PropertiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  floor: <T = FragmentableArray<FloorsOptions>>(args?: {
    where?: FloorsOptionsWhereInput;
    orderBy?: FloorsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  wallFinish: <T = FragmentableArray<WallFinishesOptions>>(args?: {
    where?: WallFinishesOptionsWhereInput;
    orderBy?: WallFinishesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roofing: <T = FragmentableArray<RoofingMaterialOptions>>(args?: {
    where?: RoofingMaterialOptionsWhereInput;
    orderBy?: RoofingMaterialOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isSecure: <T = SelectOptionsPromise>() => T;
  pest: <T = SelectOptionsPromise>() => T;
  windows: () => Promise<Int>;
  location: <T = LocationsPromise>() => T;
  amenities: <T = FragmentableArray<AmenitiesOptions>>(args?: {
    where?: AmenitiesOptionsWhereInput;
    orderBy?: AmenitiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<String>;
  vas: <T = FragmentableArray<ValueAddedServices>>(args?: {
    where?: ValueAddedServicesWhereInput;
    orderBy?: ValueAddedServicesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  listingPhotos: <T = FragmentableArray<ListingPhotos>>(args?: {
    where?: ListingPhotosWhereInput;
    orderBy?: ListingPhotosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  frequency: <T = ListingsFrequenciesPromise>() => T;
  requirements: <T = FragmentableArray<ListingRequirements>>(args?: {
    where?: ListingRequirementsWhereInput;
    orderBy?: ListingRequirementsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  products: <T = FragmentableArray<ListingProducts>>(args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availability: <T = ListingAvailabilityPromise>() => T;
  dimensions: <T = ListingDimensionsPromise>() => T;
  status: () => Promise<Int>;
  rating: <T = ListingRatingPromise>() => T;
}

export interface ListingSubscription
  extends Promise<AsyncIterator<Listing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  discount: () => Promise<AsyncIterator<Int>>;
  currency: () => Promise<AsyncIterator<String>>;
  proofOfOwnership: () => Promise<AsyncIterator<String>>;
  identification: <T = WarehouserIdentificationSubscription>() => T;
  spacing: <T = Promise<AsyncIterator<SpacesOptionsSubscription>>>(args?: {
    where?: SpacesOptionsWhereInput;
    orderBy?: SpacesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  property: <T = Promise<AsyncIterator<PropertiesOptionsSubscription>>>(args?: {
    where?: PropertiesOptionsWhereInput;
    orderBy?: PropertiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  floor: <T = Promise<AsyncIterator<FloorsOptionsSubscription>>>(args?: {
    where?: FloorsOptionsWhereInput;
    orderBy?: FloorsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  wallFinish: <
    T = Promise<AsyncIterator<WallFinishesOptionsSubscription>>
  >(args?: {
    where?: WallFinishesOptionsWhereInput;
    orderBy?: WallFinishesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roofing: <
    T = Promise<AsyncIterator<RoofingMaterialOptionsSubscription>>
  >(args?: {
    where?: RoofingMaterialOptionsWhereInput;
    orderBy?: RoofingMaterialOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isSecure: <T = SelectOptionsSubscription>() => T;
  pest: <T = SelectOptionsSubscription>() => T;
  windows: () => Promise<AsyncIterator<Int>>;
  location: <T = LocationsSubscription>() => T;
  amenities: <T = Promise<AsyncIterator<AmenitiesOptionsSubscription>>>(args?: {
    where?: AmenitiesOptionsWhereInput;
    orderBy?: AmenitiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<AsyncIterator<String>>;
  vas: <T = Promise<AsyncIterator<ValueAddedServicesSubscription>>>(args?: {
    where?: ValueAddedServicesWhereInput;
    orderBy?: ValueAddedServicesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  listingPhotos: <
    T = Promise<AsyncIterator<ListingPhotosSubscription>>
  >(args?: {
    where?: ListingPhotosWhereInput;
    orderBy?: ListingPhotosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  frequency: <T = ListingsFrequenciesSubscription>() => T;
  requirements: <
    T = Promise<AsyncIterator<ListingRequirementsSubscription>>
  >(args?: {
    where?: ListingRequirementsWhereInput;
    orderBy?: ListingRequirementsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  products: <T = Promise<AsyncIterator<ListingProductsSubscription>>>(args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availability: <T = ListingAvailabilitySubscription>() => T;
  dimensions: <T = ListingDimensionsSubscription>() => T;
  status: () => Promise<AsyncIterator<Int>>;
  rating: <T = ListingRatingSubscription>() => T;
}

export interface ListingNullablePromise
  extends Promise<Listing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  user: <T = UserPromise>() => T;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  discount: () => Promise<Int>;
  currency: () => Promise<String>;
  proofOfOwnership: () => Promise<String>;
  identification: <T = WarehouserIdentificationPromise>() => T;
  spacing: <T = FragmentableArray<SpacesOptions>>(args?: {
    where?: SpacesOptionsWhereInput;
    orderBy?: SpacesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  property: <T = FragmentableArray<PropertiesOptions>>(args?: {
    where?: PropertiesOptionsWhereInput;
    orderBy?: PropertiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  floor: <T = FragmentableArray<FloorsOptions>>(args?: {
    where?: FloorsOptionsWhereInput;
    orderBy?: FloorsOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  wallFinish: <T = FragmentableArray<WallFinishesOptions>>(args?: {
    where?: WallFinishesOptionsWhereInput;
    orderBy?: WallFinishesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roofing: <T = FragmentableArray<RoofingMaterialOptions>>(args?: {
    where?: RoofingMaterialOptionsWhereInput;
    orderBy?: RoofingMaterialOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isSecure: <T = SelectOptionsPromise>() => T;
  pest: <T = SelectOptionsPromise>() => T;
  windows: () => Promise<Int>;
  location: <T = LocationsPromise>() => T;
  amenities: <T = FragmentableArray<AmenitiesOptions>>(args?: {
    where?: AmenitiesOptionsWhereInput;
    orderBy?: AmenitiesOptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avatar: () => Promise<String>;
  vas: <T = FragmentableArray<ValueAddedServices>>(args?: {
    where?: ValueAddedServicesWhereInput;
    orderBy?: ValueAddedServicesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  listingPhotos: <T = FragmentableArray<ListingPhotos>>(args?: {
    where?: ListingPhotosWhereInput;
    orderBy?: ListingPhotosOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  frequency: <T = ListingsFrequenciesPromise>() => T;
  requirements: <T = FragmentableArray<ListingRequirements>>(args?: {
    where?: ListingRequirementsWhereInput;
    orderBy?: ListingRequirementsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  products: <T = FragmentableArray<ListingProducts>>(args?: {
    where?: ListingProductsWhereInput;
    orderBy?: ListingProductsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  availability: <T = ListingAvailabilityPromise>() => T;
  dimensions: <T = ListingDimensionsPromise>() => T;
  status: () => Promise<Int>;
  rating: <T = ListingRatingPromise>() => T;
}

export interface RoofingMaterialOptionsConnection {
  pageInfo: PageInfo;
  edges: RoofingMaterialOptionsEdge[];
}

export interface RoofingMaterialOptionsConnectionPromise
  extends Promise<RoofingMaterialOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoofingMaterialOptionsEdge>>() => T;
  aggregate: <T = AggregateRoofingMaterialOptionsPromise>() => T;
}

export interface RoofingMaterialOptionsConnectionSubscription
  extends Promise<AsyncIterator<RoofingMaterialOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<RoofingMaterialOptionsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateRoofingMaterialOptionsSubscription>() => T;
}

export interface SelectOptionsSubscriptionPayload {
  mutation: MutationType;
  node: SelectOptions;
  updatedFields: String[];
  previousValues: SelectOptionsPreviousValues;
}

export interface SelectOptionsSubscriptionPayloadPromise
  extends Promise<SelectOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SelectOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SelectOptionsPreviousValuesPromise>() => T;
}

export interface SelectOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SelectOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SelectOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SelectOptionsPreviousValuesSubscription>() => T;
}

export interface RequisitionDurationConnection {
  pageInfo: PageInfo;
  edges: RequisitionDurationEdge[];
}

export interface RequisitionDurationConnectionPromise
  extends Promise<RequisitionDurationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequisitionDurationEdge>>() => T;
  aggregate: <T = AggregateRequisitionDurationPromise>() => T;
}

export interface RequisitionDurationConnectionSubscription
  extends Promise<AsyncIterator<RequisitionDurationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<RequisitionDurationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateRequisitionDurationSubscription>() => T;
}

export interface SelectOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
}

export interface SelectOptionsPreviousValuesPromise
  extends Promise<SelectOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SelectOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<SelectOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Auth {
  id: ID_Output;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  phoneNumber: String;
  pin: String;
  userId: String;
}

export interface AuthPromise extends Promise<Auth>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phoneNumber: () => Promise<String>;
  pin: () => Promise<String>;
  userId: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface AuthSubscription
  extends Promise<AsyncIterator<Auth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface AuthNullablePromise
  extends Promise<Auth | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phoneNumber: () => Promise<String>;
  pin: () => Promise<String>;
  userId: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface AggregateIdentificationsOptions {
  count: Int;
}

export interface AggregateIdentificationsOptionsPromise
  extends Promise<AggregateIdentificationsOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIdentificationsOptionsSubscription
  extends Promise<AsyncIterator<AggregateIdentificationsOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Rating {
  id: ID_Output;
  listingId: String;
  ratingId: String;
  rate: Int;
  userId: String;
}

export interface RatingPromise extends Promise<Rating>, Fragmentable {
  id: () => Promise<ID_Output>;
  listingId: () => Promise<String>;
  ratingId: () => Promise<String>;
  rate: () => Promise<Int>;
  userId: () => Promise<String>;
}

export interface RatingSubscription
  extends Promise<AsyncIterator<Rating>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  listingId: () => Promise<AsyncIterator<String>>;
  ratingId: () => Promise<AsyncIterator<String>>;
  rate: () => Promise<AsyncIterator<Int>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface RatingNullablePromise
  extends Promise<Rating | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  listingId: () => Promise<String>;
  ratingId: () => Promise<String>;
  rate: () => Promise<Int>;
  userId: () => Promise<String>;
}

export interface SpacesOptionsSubscriptionPayload {
  mutation: MutationType;
  node: SpacesOptions;
  updatedFields: String[];
  previousValues: SpacesOptionsPreviousValues;
}

export interface SpacesOptionsSubscriptionPayloadPromise
  extends Promise<SpacesOptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpacesOptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpacesOptionsPreviousValuesPromise>() => T;
}

export interface SpacesOptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpacesOptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpacesOptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpacesOptionsPreviousValuesSubscription>() => T;
}

export interface Otp {
  id: ID_Output;
  phoneNumber: String;
  code: String;
  validated: Boolean;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface OtpPromise extends Promise<Otp>, Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  code: () => Promise<String>;
  validated: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OtpSubscription
  extends Promise<AsyncIterator<Otp>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  validated: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OtpNullablePromise extends Promise<Otp | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  phoneNumber: () => Promise<String>;
  code: () => Promise<String>;
  validated: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SpacesOptionsPreviousValues {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface SpacesOptionsPreviousValuesPromise
  extends Promise<SpacesOptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface SpacesOptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<SpacesOptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface Organization {
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  id: ID_Output;
  name?: String;
  email: String;
  phoneNumber: String;
}

export interface OrganizationPromise
  extends Promise<Organization>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  type: <T = OrganizationTypePromise>() => T;
  phoneNumber: () => Promise<String>;
  bank: <T = BankPromise>() => T;
}

export interface OrganizationSubscription
  extends Promise<AsyncIterator<Organization>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  type: <T = OrganizationTypeSubscription>() => T;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  bank: <T = BankSubscription>() => T;
}

export interface OrganizationNullablePromise
  extends Promise<Organization | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  type: <T = OrganizationTypePromise>() => T;
  phoneNumber: () => Promise<String>;
  bank: <T = BankPromise>() => T;
}

export interface IdentificationsOptionsEdge {
  node: IdentificationsOptions;
  cursor: String;
}

export interface IdentificationsOptionsEdgePromise
  extends Promise<IdentificationsOptionsEdge>,
    Fragmentable {
  node: <T = IdentificationsOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IdentificationsOptionsEdgeSubscription
  extends Promise<AsyncIterator<IdentificationsOptionsEdge>>,
    Fragmentable {
  node: <T = IdentificationsOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthEdge {
  node: Auth;
  cursor: String;
}

export interface AuthEdgePromise extends Promise<AuthEdge>, Fragmentable {
  node: <T = AuthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthEdgeSubscription
  extends Promise<AsyncIterator<AuthEdge>>,
    Fragmentable {
  node: <T = AuthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StatesSubscriptionPayload {
  mutation: MutationType;
  node: States;
  updatedFields: String[];
  previousValues: StatesPreviousValues;
}

export interface StatesSubscriptionPayloadPromise
  extends Promise<StatesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StatesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StatesPreviousValuesPromise>() => T;
}

export interface StatesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StatesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StatesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StatesPreviousValuesSubscription>() => T;
}

export interface AggregateListingProducts {
  count: Int;
}

export interface AggregateListingProductsPromise
  extends Promise<AggregateListingProducts>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingProductsSubscription
  extends Promise<AsyncIterator<AggregateListingProducts>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StatesPreviousValues {
  id: ID_Output;
  countryId: String;
  slug?: String;
  name?: String;
  default?: Boolean;
}

export interface StatesPreviousValuesPromise
  extends Promise<StatesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  countryId: () => Promise<String>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
}

export interface StatesPreviousValuesSubscription
  extends Promise<AsyncIterator<StatesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  countryId: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
}

export interface ListingDimensionsConnection {
  pageInfo: PageInfo;
  edges: ListingDimensionsEdge[];
}

export interface ListingDimensionsConnectionPromise
  extends Promise<ListingDimensionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingDimensionsEdge>>() => T;
  aggregate: <T = AggregateListingDimensionsPromise>() => T;
}

export interface ListingDimensionsConnectionSubscription
  extends Promise<AsyncIterator<ListingDimensionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingDimensionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingDimensionsSubscription>() => T;
}

export interface IdentificationsOptionsConnection {
  pageInfo: PageInfo;
  edges: IdentificationsOptionsEdge[];
}

export interface IdentificationsOptionsConnectionPromise
  extends Promise<IdentificationsOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IdentificationsOptionsEdge>>() => T;
  aggregate: <T = AggregateIdentificationsOptionsPromise>() => T;
}

export interface IdentificationsOptionsConnectionSubscription
  extends Promise<AsyncIterator<IdentificationsOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<IdentificationsOptionsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateIdentificationsOptionsSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface SuccessSubscriptionPayload {
  mutation: MutationType;
  node: Success;
  updatedFields: String[];
  previousValues: SuccessPreviousValues;
}

export interface SuccessSubscriptionPayloadPromise
  extends Promise<SuccessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SuccessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SuccessPreviousValuesPromise>() => T;
}

export interface SuccessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SuccessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SuccessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SuccessPreviousValuesSubscription>() => T;
}

export interface SelectOptionsConnection {
  pageInfo: PageInfo;
  edges: SelectOptionsEdge[];
}

export interface SelectOptionsConnectionPromise
  extends Promise<SelectOptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SelectOptionsEdge>>() => T;
  aggregate: <T = AggregateSelectOptionsPromise>() => T;
}

export interface SelectOptionsConnectionSubscription
  extends Promise<AsyncIterator<SelectOptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SelectOptionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSelectOptionsSubscription>() => T;
}

export interface SuccessPreviousValues {
  id: ID_Output;
  success: Boolean;
}

export interface SuccessPreviousValuesPromise
  extends Promise<SuccessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  success: () => Promise<Boolean>;
}

export interface SuccessPreviousValuesSubscription
  extends Promise<AsyncIterator<SuccessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  success: () => Promise<AsyncIterator<Boolean>>;
}

export interface RequisitionCostConnection {
  pageInfo: PageInfo;
  edges: RequisitionCostEdge[];
}

export interface RequisitionCostConnectionPromise
  extends Promise<RequisitionCostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequisitionCostEdge>>() => T;
  aggregate: <T = AggregateRequisitionCostPromise>() => T;
}

export interface RequisitionCostConnectionSubscription
  extends Promise<AsyncIterator<RequisitionCostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequisitionCostEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequisitionCostSubscription>() => T;
}

export interface AggregateCountries {
  count: Int;
}

export interface AggregateCountriesPromise
  extends Promise<AggregateCountries>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountriesSubscription
  extends Promise<AsyncIterator<AggregateCountries>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateOtp {
  count: Int;
}

export interface AggregateOtpPromise
  extends Promise<AggregateOtp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOtpSubscription
  extends Promise<AsyncIterator<AggregateOtp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AuthConnection {
  pageInfo: PageInfo;
  edges: AuthEdge[];
}

export interface AuthConnectionPromise
  extends Promise<AuthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthEdge>>() => T;
  aggregate: <T = AggregateAuthPromise>() => T;
}

export interface AuthConnectionSubscription
  extends Promise<AsyncIterator<AuthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  phoneNumber: String;
  dob: String;
  terms?: Boolean;
  type: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  dob: () => Promise<String>;
  terms: () => Promise<Boolean>;
  type: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<String>>;
  terms: () => Promise<AsyncIterator<Boolean>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface ListingPhotosEdge {
  node: ListingPhotos;
  cursor: String;
}

export interface ListingPhotosEdgePromise
  extends Promise<ListingPhotosEdge>,
    Fragmentable {
  node: <T = ListingPhotosPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingPhotosEdgeSubscription
  extends Promise<AsyncIterator<ListingPhotosEdge>>,
    Fragmentable {
  node: <T = ListingPhotosSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface IdentificationsOptions {
  id: ID_Output;
  slug?: String;
  name?: String;
  default?: Boolean;
  userId?: String;
}

export interface IdentificationsOptionsPromise
  extends Promise<IdentificationsOptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface IdentificationsOptionsSubscription
  extends Promise<AsyncIterator<IdentificationsOptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface IdentificationsOptionsNullablePromise
  extends Promise<IdentificationsOptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  default: () => Promise<Boolean>;
  userId: () => Promise<String>;
}

export interface StatesConnection {
  pageInfo: PageInfo;
  edges: StatesEdge[];
}

export interface StatesConnectionPromise
  extends Promise<StatesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StatesEdge>>() => T;
  aggregate: <T = AggregateStatesPromise>() => T;
}

export interface StatesConnectionSubscription
  extends Promise<AsyncIterator<StatesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StatesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStatesSubscription>() => T;
}

export interface AggregateRating {
  count: Int;
}

export interface AggregateRatingPromise
  extends Promise<AggregateRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRatingSubscription
  extends Promise<AsyncIterator<AggregateRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValueAddedServicesSubscriptionPayload {
  mutation: MutationType;
  node: ValueAddedServices;
  updatedFields: String[];
  previousValues: ValueAddedServicesPreviousValues;
}

export interface ValueAddedServicesSubscriptionPayloadPromise
  extends Promise<ValueAddedServicesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValueAddedServicesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValueAddedServicesPreviousValuesPromise>() => T;
}

export interface ValueAddedServicesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValueAddedServicesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValueAddedServicesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValueAddedServicesPreviousValuesSubscription>() => T;
}

export interface AggregateFloorsOptions {
  count: Int;
}

export interface AggregateFloorsOptionsPromise
  extends Promise<AggregateFloorsOptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFloorsOptionsSubscription
  extends Promise<AsyncIterator<AggregateFloorsOptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserOrganizationRolePreviousValues {
  id: ID_Output;
}

export interface UserOrganizationRolePreviousValuesPromise
  extends Promise<UserOrganizationRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface UserOrganizationRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserOrganizationRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserOrganizationRoleSubscriptionPayload {
  mutation: MutationType;
  node: UserOrganizationRole;
  updatedFields: String[];
  previousValues: UserOrganizationRolePreviousValues;
}

export interface UserOrganizationRoleSubscriptionPayloadPromise
  extends Promise<UserOrganizationRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserOrganizationRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserOrganizationRolePreviousValuesPromise>() => T;
}

export interface UserOrganizationRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserOrganizationRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserOrganizationRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserOrganizationRolePreviousValuesSubscription>() => T;
}

export interface AggregateOrganization {
  count: Int;
}

export interface AggregateOrganizationPromise
  extends Promise<AggregateOrganization>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrganizationSubscription
  extends Promise<AsyncIterator<AggregateOrganization>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AmenitiesOptionsEdge {
  node: AmenitiesOptions;
  cursor: String;
}

export interface AmenitiesOptionsEdgePromise
  extends Promise<AmenitiesOptionsEdge>,
    Fragmentable {
  node: <T = AmenitiesOptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AmenitiesOptionsEdgeSubscription
  extends Promise<AsyncIterator<AmenitiesOptionsEdge>>,
    Fragmentable {
  node: <T = AmenitiesOptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ValueAddedServicesConnection {
  pageInfo: PageInfo;
  edges: ValueAddedServicesEdge[];
}

export interface ValueAddedServicesConnectionPromise
  extends Promise<ValueAddedServicesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValueAddedServicesEdge>>() => T;
  aggregate: <T = AggregateValueAddedServicesPromise>() => T;
}

export interface ValueAddedServicesConnectionSubscription
  extends Promise<AsyncIterator<ValueAddedServicesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ValueAddedServicesEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateValueAddedServicesSubscription>() => T;
}

export interface AggregateListingRating {
  count: Int;
}

export interface AggregateListingRatingPromise
  extends Promise<AggregateListingRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingRatingSubscription
  extends Promise<AsyncIterator<AggregateListingRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "SpacesOptions",
    embedded: false
  },
  {
    name: "Locations",
    embedded: false
  },
  {
    name: "PropertiesOptions",
    embedded: false
  },
  {
    name: "WallFinishesOptions",
    embedded: false
  },
  {
    name: "ListingDimensions",
    embedded: false
  },
  {
    name: "WarehouserIdentification",
    embedded: false
  },
  {
    name: "Listing",
    embedded: false
  },
  {
    name: "Rating",
    embedded: false
  },
  {
    name: "Requisition",
    embedded: false
  },
  {
    name: "RequisitionCost",
    embedded: false
  },
  {
    name: "RequisitionDuration",
    embedded: false
  },
  {
    name: "ListingRating",
    embedded: false
  },
  {
    name: "ListingAvailability",
    embedded: false
  },
  {
    name: "ListingRequirements",
    embedded: false
  },
  {
    name: "SelectOptions",
    embedded: false
  },
  {
    name: "RoofingMaterialOptions",
    embedded: false
  },
  {
    name: "FloorsOptions",
    embedded: false
  },
  {
    name: "AmenitiesOptions",
    embedded: false
  },
  {
    name: "ValueAddedServices",
    embedded: false
  },
  {
    name: "IdentificationsOptions",
    embedded: false
  },
  {
    name: "ListingsFrequencies",
    embedded: false
  },
  {
    name: "ListingPhotos",
    embedded: false
  },
  {
    name: "States",
    embedded: false
  },
  {
    name: "Countries",
    embedded: false
  },
  {
    name: "ListingProducts",
    embedded: false
  },
  {
    name: "Organization",
    embedded: false
  },
  {
    name: "OrganizationType",
    embedded: false
  },
  {
    name: "Auth",
    embedded: false
  },
  {
    name: "Otp",
    embedded: false
  },
  {
    name: "UserOrganizationRole",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Success",
    embedded: false
  },
  {
    name: "Bank",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://167.71.135.109:4466`
});
export const prisma = new Prisma();
